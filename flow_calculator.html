<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--
     ===========================================================================
           开发更新记录 (Internal Changelog)
     ===========================================================================
    
    v3.2.1
    计划更新内容：
        1、优化保存断面的命名弹窗，以及删除断面的弹窗样式
        2、水位间隔、曼宁糙率、河道坡降的默认输入值改为灰色提示的样式，点击输入框后，提示消失
        3、优化断面数据输入框的样式，改为表格形式
        4、水位间隔、曼宁糙率、河道坡降也增加i图标
        5、修改canvas的大小，使其占满容器
        6、历史断面数据管理下拉菜单，增加编辑功能。
        7、绘图区增加流速显示

    v3.2.1 
    更新内容：
        1、优化保存断面的命名弹窗，以及删除断面的弹窗样式
        2、水位间隔、曼宁糙率、河道坡降的默认输入值改为灰色提示的样式，点击输入框后，提示消失
        3、
        4、水位间隔、曼宁糙率、河道坡降增加i图标说明
        5、优化canvas的样式，现在可以占满绘图区
        6、
        7、
        8、优化历史断面管理系统，点击保存按钮后，若选中已有断面，自动切换覆盖模式
        9、优化保存模态框的交互，增加用户输入断面名字时的检查功能

    v3.2.0
    更新内容：
         1、新增：历史断面数据管理功能，支持本地保存、加载和删除。
         2、新增：更新记录功能，支持查看更新内容。
         3、代码结构重组：对整个 <script> 标签内的代码进行了重新排序和分组。现在代码按照 全局变量 -> 核心计算函数 -> 绘图与UI更新函数 -> 历史记录管理 -> 数据查询 -> 事件处理函数 -> 主程序入口 的清晰逻辑进行组织。

    v3.1.0
    更新内容：
        1、新增：独立设置边滩糙率。
        2、优化：支持逗号、空格作为断面数据分隔符。
    -->

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="version" content="v3.2.0">
    <meta name="author" content="5-0">
    <title>断面水位流量关系计算器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style type="text/tailwindcss">
        body { 
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        }
        .input-label { 
            @apply block text-sm font-medium text-gray-700 mb-1;
        }
        .input-field { 
            @apply mt-1 w-full px-3 py-2 bg-white border border-blue-200 rounded-md shadow-sm 
            focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 
            transition duration-150 ease-in-out;
        }
        .button { 
            @apply px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white 
            focus:outline-none focus:ring-2 focus:ring-offset-2 
            transition duration-150 ease-in-out;
        }
        .button-primary { 
            @apply bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 
            focus:ring-blue-500 transform hover:scale-105 transition-transform duration-150
            shadow-lg hover:shadow-xl;
        }
        .button-secondary { 
            @apply bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 
            focus:ring-gray-500 transform hover:scale-105 transition-transform duration-150
            shadow-lg hover:shadow-xl;
        }
        .button-small { 
            @apply px-2 py-1 text-xs;
        }
        #crossSectionCanvas { 
            @apply border-2 border-blue-200 rounded-lg shadow-lg bg-white;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        table {
            @apply min-w-full divide-y divide-blue-200;
        }
        thead {
            @apply bg-blue-50;
        }
        th {
            @apply px-4 py-3 text-left text-xs font-medium text-blue-900 uppercase tracking-wider 
            border-b border-blue-200 bg-blue-50 sticky top-0;
        }
        td {
            @apply px-4 py-4 whitespace-nowrap text-sm text-gray-600 border-b border-blue-100;
        }
        tbody tr:nth-child(even) {
            @apply bg-blue-50;
        }
        tbody tr:hover {
            @apply bg-blue-100 transition-colors duration-150;
        }
        .remark-flood {
            @apply text-red-600 font-medium;
        }
        .remark-main {
            @apply text-green-600 font-medium;
        }
        #noResultsMessage {
            @apply text-center text-gray-500 py-8 bg-blue-50 border-t border-blue-200;
        }
        #statusMessage { 
            @apply mt-4 p-4 rounded-md text-sm font-medium;
        }
        .error { 
            @apply text-red-700;
        }
        .success { 
            @apply text-green-700;
        }
        .card {
            @apply bg-white rounded-lg shadow-lg p-6 border border-blue-100
            hover:shadow-xl transition-shadow duration-300;
        }
        .section-title {
            @apply text-lg font-semibold text-blue-900 mb-4 border-b border-blue-200 pb-2;
        }
        .checkbox-wrapper {
            @apply flex items-center space-x-2 p-2 rounded-md hover:bg-blue-50 transition-colors duration-150;
        }
        input[type="checkbox"] {
            @apply w-4 h-4 text-blue-600 border-blue-300 rounded 
            focus:ring-blue-500 cursor-pointer;
        }
        tbody tr {
            @apply cursor-pointer transition-all duration-150;
        }
        tbody tr.selected {
            background-color: #bee3f8 !important; /* Tailwind's blue-200 */
        }
        tbody tr:hover:not(.selected) {
            background-color: #ebf8ff !important; /* Tailwind's blue-100 */
        }
        .parameter-box {
            @apply absolute bg-white/90 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-blue-200 
            text-sm text-gray-700 transition-opacity duration-150;
        }
        .parameter-value {
            @apply font-medium text-blue-600;
        }
        .main-container {
            @apply grid grid-cols-5 gap-6;
            min-height: calc(100vh - 200px);
        }
        .left-section {
            @apply col-span-3 grid grid-rows-[auto_1fr] gap-6;
        }
        .right-section {
            @apply col-span-2 space-y-6;
        }
        .params-section {
            @apply grid grid-cols-2 gap-6;
        }
        .params-box {
            @apply bg-gradient-to-r from-blue-50 to-blue-100 backdrop-blur-sm py-2 px-4 rounded-lg 
            shadow-sm border border-blue-200 flex items-center justify-start space-x-4 text-sm;
        }
        .param-item {
            @apply flex items-center space-x-2 text-blue-800;
        }
        .param-value {
            @apply font-medium text-blue-700;
        }

        .step-number {
            @apply absolute -left-6 -top-6 w-12 h-12 rounded-full bg-blue-600 text-white
            flex items-center justify-center font-bold text-2xl shadow-lg;
        }
        .highlight-section {
            @apply relative bg-gradient-to-br from-blue-50 to-white rounded-xl p-6 shadow-lg
            border-2 border-blue-200;
        }
        .param-inputs {
            @apply space-y-3 mt-4;
        }
        .param-row {
            @apply flex items-center gap-4;
        }
        .param-label {
            @apply w-1/3 text-right font-medium text-blue-800 whitespace-nowrap;
        }
        .param-input {
            @apply w-2/3 px-3 py-2 bg-white border border-blue-200 rounded-md shadow-sm 
            focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 
            transition duration-150 ease-in-out;
        }

        /* 提示容器 */
        .tooltip-container {
            position: relative; /* 这是关键，为子元素的绝对定位提供基准 */
            display: inline-block; /* 让容器大小适应内容 */
            cursor: pointer;
        }

        /* "i" 图标的样式 */
        .info-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #007bff;
            color: white;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-weight: bold;
            line-height: 20px;
        }

        /* 提示文本框的默认样式 (隐藏) */
        .tooltip-text {
            visibility: hidden; /* 默认隐藏 */
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            
            /* 定位 */
            position: absolute;
            z-index: 1;
            bottom: 125%; /* 将提示框定位在图标上方 */
            left: 50%;
            margin-left: -100px; /* 将提示框水平居中 */

            /* 淡入淡出效果 */
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* 悬停时显示提示文本框 */
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-50 p-4 md:p-8">
    <div class="container mx-auto max-w-10xl">
        <div class="relative text-center mb-8">
            <h1 class="text-3xl font-bold text-blue-700 inline-block">断面水位流量关系计算器</h1>
            <button id="showChangelogBtn" class="absolute right-0 top-1/2 -translate-y-1/2 text-sm text-blue-600 hover:underline focus:outline-none px-4 py-2">
                更新记录
            </button>
        </div>

        <div class="main-container">
            <div class="left-section">
                <!-- 上部参数区域 -->
                <div class="params-section">
                    <!-- 基本参数 -->
                    <div class="highlight-section h-full flex flex-col min-h-[500px]">
                        <div class="step-number">1</div>
                        <h2 class="section-title">基本参数输入</h2>
                        <div class="space-y-2">
                            <div>
                                <div id="historyDropdown" class="relative">
                                    <button id="historyDropdownButton" type="button" class="input-field flex justify-between items-center w-full text-left">
                                        <span id="historyDropdownLabel" class="text-gray-500">选择历史断面数据...</span>
                                        <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 9l4-4 4 4m0 6l-4 4-4-4"></path>
                                        </svg>
                                    </button>
                            
                                    <div id="historyDropdownPanel" class="hidden absolute z-10 mt-1 w-full bg-white shadow-lg border border-gray-200 rounded-md max-h-60 overflow-auto">
                                    </div>
                                </div>
                            </div>

                            <div>
                                <label for="sectionData" class="input-label">编辑断面数据
                                    <span class = "tooltip-container">
                                        <span class="info-icon">i</span>
                                        <span class="tooltip-text">
                                            断面数据 (平距+高程，由换行符、空格或英文逗号分隔)
                                        </span>
                                    </span>
                                </label>
                                <textarea id="sectionData" rows="7" class="input-field font-mono text-sm" placeholder="例如:&#10;0 100&#10;10 95&#10;20 92&#10;30 95&#10;40 100">0	88
10	84.813
40	84.813
51.279	84.81
51.657	85.069
53.462	84.694
55.898	82.977
57.978	81.9
60.126	81.23
62.555	80.77
66.298	80.75
70.061	80.95
73.248	81.15
75.808	81.9
77.505	83.583
78.55	83.958
82.581	85.823
84.542	85.927
85.186	85.732
94.934	85.83
96.465	86.721
99.923	86.734
100	88</textarea>
                            </div>

                                <button id="saveSectionButton" class="button button-primary w-full">
                                    <span class="flex items-center justify-center">
                                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                                        </svg>
                                        保存断面
                                    </span>
                                </button>
                            
                            <div class="param-inputs">
                                <div class="param-row">
                                    <label for="waterLevelInterval" class="param-label">水位间隔
                                        <span class = "tooltip-container">
                                            <span class="info-icon">i</span>
                                            <span class="tooltip-text">
                                                调整计算的精度，单位为m
                                            </span>
                                        </span>
                                    </label>
                                    <input type="number" id="waterLevelInterval" class="param-input" placeholder="0.5" step="0.1">
                                </div>
                                <div class="param-row">
                                    <label for="manningN_mc" class="param-label">曼宁系数(n)
                                        <span class = "tooltip-container">
                                            <span class="info-icon">i</span>
                                            <span class="tooltip-text">
                                                取值可参考《水力计算手册》
                                            </span>
                                        </span>
                                    </label>
                                    <input type="number" id="manningN_mc" class="param-input" placeholder="0.03" step="0.001">
                                </div>
                                <div class="param-row">
                                    <label for="channelSlope" class="param-label">河道坡降(J)
                                        <span class = "tooltip-container">
                                            <span class="info-icon">i</span>
                                            <span class="tooltip-text">
                                                如1‰，则输入0.001
                                            </span>
                                        </span>
                                    </label>
                                    <input type="number" id="channelSlope" class="param-input" placeholder="0.00177" step="0.0001">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 计算选项 -->
                    <div class="highlight-section h-full flex flex-col min-h-[500px]">
                        <div class="step-number">2</div>
                        <h2 class="section-title">计算选项设置</h2>
                        
                        <!-- 选项内容区域 -->
                        <div class="flex-grow space-y-4">
                            <div class="input-group">
                                <div class="checkbox-wrapper">
                                    <input id="useManualWaterLevels" type="checkbox">
                                    <label for="useManualWaterLevels" class="text-sm text-gray-700">手动设定计算水位范围</label>
                                </div>
                                <div id="manualWaterLevelControls" class="hidden flex space-x-4 items-end pl-6 mt-2">
                                    <div>
                                        <label for="manualStartWL" class="input-label">起始水位 (m):</label>
                                        <input type="number" id="manualStartWL" class="input-field" step="0.1" placeholder="例如: 80.0">
                                    </div>
                                    <div>
                                        <label for="manualEndWL" class="input-label">终止水位 (m):</label>
                                        <input type="number" id="manualEndWL" class="input-field" step="0.1" placeholder="例如: 88.0">
                                    </div>
                                </div>
                            </div>

                            <div class="input-group">
                                <div class="checkbox-wrapper">
                                    <input id="considerFloodplain" type="checkbox">
                                    <label for="considerFloodplain" class="text-sm text-gray-700">考虑漫滩计算</label>
                                </div>

                                <div id="floodplainControls" class="hidden space-y-3 pl-6 mt-2">
                                    <p class="text-sm text-blue-700 font-medium">调整主槽岸顶 (红点):</p>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="input-label">左岸顶:</label>
                                            <div class="flex space-x-2">
                                                <button id="leftBankPrev" class="button button-secondary button-small">← 左移</button>
                                                <button id="leftBankNext" class="button button-secondary button-small">右移 →</button>
                                            </div>
                                            <p id="leftBankInfo" class="text-xs text-gray-500 mt-1">-</p>
                                        </div>
                                        <div>
                                            <label class="input-label">右岸顶:</label>
                                            <div class="flex space-x-2">
                                                <button id="rightBankPrev" class="button button-secondary button-small">← 左移</button>
                                                <button id="rightBankNext" class="button button-secondary button-small">右移 →</button>
                                            </div>
                                            <p id="rightBankInfo" class="text-xs text-gray-500 mt-1">-</p>
                                        </div>
                                    </div>
                                    <div class="mt-4 pt-4 border-t border-blue-200">
                                        <p class="text-sm text-blue-700 font-medium mb-2">边滩糙率 (可选, 留空则同主槽):</p>
                                        <div class="grid grid-cols-2 gap-4">
                                            <div>
                                                <label for="manningN_lfp" class="input-label">左滩糙率 (n<sub class="text-xs">左</sub>):</label>
                                                <input type="number" id="manningN_lfp" class="param-input text-sm" placeholder="同主槽" step="0.001">
                                            </div>
                                            <div>
                                                <label for="manningN_rfp" class="input-label">右滩糙率 (n<sub class="text-xs">右</sub>):</label>
                                                <input type="number" id="manningN_rfp" class="param-input text-sm" placeholder="同主槽" step="0.001">
                                            </div>
                                        </div>
                                    </div>
                                </div>    
                            </div>
                        </div>

                        <!-- 按钮区域 - 始终在底部 -->
                        <div class="mt-auto pt-4 border-t border-blue-200">
                            <div class="flex space-x-4">
                                <button id="updatePreviewButton" class="button button-primary flex-1">
                                    <span class="flex items-center justify-center">
                                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                        </svg>
                                        预览/更新断面
                                    </span>
                                </button>
                                <button id="calculateButton" class="button button-primary bg-green-600 hover:bg-green-700 flex-1">
                                    <span class="flex items-center justify-center">
                                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                                        </svg>
                                        计算
                                    </span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 下部绘图区域 -->
                <div class="highlight-section h-full">
                    <div id="parameterDisplay" class="absolute top-12 left-1/2 -translate-x-1/2 hidden params-box z-10">
                        <div class="param-item">
                            <span>过水面积:</span>
                            <span class="param-value" id="paramArea">-</span>
                            <span>m²</span>
                        </div>
                        <div class="param-item">
                            <span>湿周:</span>
                            <span class="param-value" id="paramPerimeter">-</span>
                            <span>m</span>
                        </div>
                        <div class="param-item">
                            <span>流量:</span>
                            <span class="param-value" id="paramFlow">-</span>
                            <span>m³/s</span>
                        </div>
                    </div>
                    <canvas id="crossSectionCanvas" class="absolute inset-0 w-full h-full"></canvas>
                </div>
            </div>

            <!-- 右侧结果区域 -->
            <div class="right-section">
                <div class="highlight-section h-full flex flex-col"> 
                    <div class="step-number">3</div>
                    
                    <!-- 标题和复制按钮 -->
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-baseline gap-1">
                            <h2 class="section-title mb-0">计算结果</h2>
                            <div id="statusMessage"></div>
                        </div>
                        <button id="copyResultsButton" class="button button-secondary">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                </svg>
                                复制结果
                            </span>
                        </button>
                    </div>

                    <!-- 查询功能区域 -->
                    <div class="mt-2">
                        <div class="mb-4 flex items-baseline gap-1">
                            <h3 class="text-lg font-medium text-blue-700 mb-2">水位流量查询：</h3>
                            <p id="queryResultText" class="text-sm text-gray-600 pl-1 hidden"></p>
                        </div>
                        <div class="space-y-4">
                            <!-- 水位查询流量 -->
                            <div class="flex items-center space-x-2">
                                <div class="flex-1">
                                    <input type="number" id="queryWaterLevel" class="input-field py-1 text-sm" step="0.01" placeholder="输入水位...">
                                </div>
                                <button id="queryFlowByLevel" class="button button-primary py-1 px-3 text-sm">
                                    查询流量
                                </button>
                            </div>
                            <!-- 流量查询水位 -->
                            <div class="flex items-center space-x-2">
                                <div class="flex-1">
                                    <input type="number" id="queryFlow" class="input-field py-1 text-sm" step="0.01" placeholder="输入流量...">
                                </div>
                                <button id="queryLevelByFlow" class="button button-primary py-1 px-3 text-sm">
                                    查询水位
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 结果表格 -->
                    <div class="mt-6 overflow-auto max-h-[calc(100vh-500px)]" >
                        <table id="resultsTable" class="w-full">
                            <thead class="sticky top-0 bg-gray-50 shadow-sm">
                                <tr>
                                    <th>水位 (m)</th>
                                    <th>过水面积 (m²)</th>
                                    <th>湿周 (m)</th>
                                    <th>水力半径 (m)</th>
                                    <th>流量 (m³/s)</th>
                                    <th>备注</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div id="noResultsMessage" class="hidden text-center text-gray-500 py-8 bg-blue-50 border-t border-blue-200">无计算结果</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 水位流量关系图区域 -->
        <div class="mt-8">
            <h2 class="text-2xl font-bold text-center text-indigo-700 mb-6">水位流量关系图</h2>
            <div class="grid grid-cols-4 gap-6">
                <!-- 左侧绘图区 -->
                <div class="col-span-3">
                    <div class="card">
                        <canvas id="qhCanvas" width="800" height="500" class="w-full h-auto"></canvas>
                    </div>
                </div>
                
                <!-- 右侧配置面板 -->
                <div class="col-span-1">
                    <div class="card space-y-6">
                        <h3 class="text-lg font-semibold text-gray-800">图表设置</h3>
                        
                        <!-- 基本显示设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">基本设置</h4>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showGrid" checked>
                                <label for="showGrid">显示网格</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showPoints" checked>
                                <label for="showPoints">显示数据点</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showDataLabels">
                                <label for="showDataLabels">显示数据标签</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="smoothLine">
                                <label for="smoothLine">平滑曲线</label>
                            </div>
                        </div>

                        <!-- 流量轴（X轴）设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">流量轴设置（横轴）</h4>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="input-label">最小值</label>
                                    <input type="number" id="xAxisMin" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">最大值</label>
                                    <input type="number" id="xAxisMax" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">主刻度间距</label>
                                    <input type="number" id="xAxisStep" class="input-field" placeholder="自动">
                                </div>
                            </div>
                        </div>

                        <!-- 水位轴（Y轴）设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">水位轴设置（纵轴）</h4>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="input-label">最小值</label>
                                    <input type="number" id="yAxisMin" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">最大值</label>
                                    <input type="number" id="yAxisMax" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">主刻度间距</label>
                                    <input type="number" id="yAxisStep" class="input-field" placeholder="自动">
                                </div>
                            </div>
                        </div>

                        <!-- 图表操作按钮 -->
                        <div class="pt-4 border-t border-gray-200">
                            <button id="updateQHPlotButton" class="button button-primary w-full">
                                <span class="flex items-center justify-center">
                                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                    更新图表
                                </span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 更新记录模态框 -->
    <div id="changelogModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4 transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center p-4 border-b">
                <h2 class="text-xl font-bold text-left text-gray-800">更新记录</h2>
                <button id="closeChangelogBtn" class="text-3xl text-gray-400 hover:text-gray-800 transition-colors">&times;</button>
            </div>
            <div class="p-6 overflow-y-auto space-y-4">
                <div>
                    <h3 class="font-bold text-lg mb-1 text-gray-800">v3.2</h3>
                    <ul class="list-disc list-inside space-y-1 text-gray-700">
                        <li>新增：历史断面数据管理功能，支持本地保存、加载和删除。</li>
                    </ul>
                </div>
                <hr>
                <div>
                    <h3 class="font-bold text-lg mb-1 text-gray-800">v3.1</h3>
                    <ul class="list-disc list-inside space-y-1 text-gray-700">
                        <li>新增：独立设置边滩糙率。</li>
                        <li>优化：支持逗号、空格作为断面数据分隔符。</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- 保存断面模态框 -->
    <div id="saveSectionModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
            <div class="p-6">
                <h2 id="saveSectionTitle" class="text-xl font-bold text-gray-800 mb-4"></h2>
                <p id="saveSectionDescription" class="text-sm text-gray-600 mb-4"></p>
                
                <div id="nameInputGroup" class="hidden">
                    <label for="sectionNameInput" class="input-label">断面名称:</label>
                    <input type="text" id="sectionNameInput" class="input-field" placeholder="例如：某某桥上游断面">
                </div>
                <div>
                    <p id="nameInputNotification" class="text-red-600 text-xs mt-2 h-4"></p>
                </div>
            </div>
            <div class="bg-gray-50 px-6 py-4 flex justify-end gap-3 rounded-b-lg">
                <button id="OverwriteBtn" type="button" class="button button-primary hidden">覆盖</button>
                <button id="SaveAsNewBtn" type="button" class="button button-secondary hidden">另存为</button>
                <button id="SaveBtn" type="button" class="button button-primary hidden">保存</button>
                <button id="CancelSaveBtn" type="button" class="button bg-gray-400 hover:bg-gray-500">取消</button>
            </div>
        </div>
    </div>

    <!-- 删除断面模态框 -->
    <div id="deleteConfirmModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
            <div class="p-6 text-center">
                <svg class="mx-auto mb-4 w-14 h-14 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                <h3 class="text-lg font-semibold text-gray-800">确认删除</h3>
                <p class="mt-2 text-sm text-gray-600">您确定要删除断面 “<span id="sectionNameToDelete" class="font-bold"></span>” 吗？<br>此操作无法撤销。</p>
            </div>
            <div class="bg-gray-50 px-6 py-4 flex justify-end gap-3 rounded-b-lg">
                <button id="confirmDeleteBtn" type="button" class="button bg-red-600 hover:bg-red-700 focus:ring-red-500">确认删除</button>
                <button id="cancelDeleteBtn" type="button" class="button bg-gray-400 hover:bg-gray-500">取消</button>
            </div>
        </div>
    </div>

    <script>
    // =================================================================================
    // 1. 全局变量和状态管理 (Global Variables & State Management)
    //    这些变量定义了应用的当前状态，不依赖于DOM。
    // =================================================================================

    let parsedSectionPoints = []; // 存储解析和排序后的断面点 {x, y, originalIndex}
    let leftBankPointIndex = -1; // 左岸顶点的索引
    let rightBankPointIndex = -1; // 右岸顶点的索引
    let hBankfull = -1; // 漫滩临界岸顶高程 (min(YL, YR))
    let resultsData = []; // 存储完整的计算结果对象数组
    let sectionNameToDeleteState = null;
    let activeSectionName = null;
    const STORAGE_KEY = 'crossSectionHistory'; // 用于localStorage的键名

    // 水位流量关系图 (Q-H Plot) 的配置对象
    let qhPlotConfig = {
        showGrid: true,
        showPoints: true,
        showDataLabels: false,
        smoothLine: false,
        xAxis: { min: null, max: null, step: null },
        yAxis: { min: null, max: null, step: null }
    };

    // =================================================================================
    // 2. 核心计算与逻辑函数 (Core Calculation & Logic Functions)
    //    这部分是应用的核心引擎，处理数据解析、水力学计算和绘图辅助计算。
    // =================================================================================

    /**
     * 解析文本域中的断面数据。
     * @returns {boolean} - 如果解析成功返回 true，否则返回 false。
     */
    function parseSectionData() {
        // ... 函数体在事件处理函数部分，因为它需要访问DOM元素来显示状态消息 ...
        // 为了结构清晰，这里只做声明，具体实现在 handleUpdatePreview 中调用
        // 实际的实现被移到了 handleUpdatePreview 和 handleCalculate 内部，以确保在需要时才解析
    }

    /**
     * 计算给定水位下一个断面段的水力学几何属性（面积、湿周）。
     * @param {Array<Object>} segmentPoints - 包含 {x, y} 点的断面段。
     * @param {number} waterLevel - 当前计算的水位高程。
     * @returns {Object} - 包含 {area, bedPerimeter, intersectionPoints} 的对象。
     */
    function calculateGeometricProperties(segmentPoints, waterLevel) {
        let area = 0;
        let bedPerimeter = 0;
        let intersectionPoints = [];
        
        if (!segmentPoints || segmentPoints.length < 2) {
            return { area: 0, bedPerimeter: 0, intersectionPoints: [] };
        }

        for (let i = 0; i < segmentPoints.length - 1; i++) {
            const p1 = segmentPoints[i];
            const p2 = segmentPoints[i + 1];
            const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
            const dx = x2 - x1;

            if (y1 >= waterLevel && y2 >= waterLevel) continue; // 整个线段都在水面以上

            if (y1 < waterLevel && y2 < waterLevel) { // 整个线段都在水面以下
                area += dx * (waterLevel - (y1 + y2) / 2);
                bedPerimeter += Math.sqrt(dx * dx + (y2 - y1) * (y2 - y1));
            } else { // 线段与水面相交
                const ix = x1 + dx * (waterLevel - y1) / (y2 - y1);
                intersectionPoints.push({ x: ix, y: waterLevel });

                if (y1 < waterLevel) { // p1在水下
                    area += (ix - x1) * (waterLevel - y1) / 2;
                    bedPerimeter += Math.sqrt(Math.pow(ix - x1, 2) + Math.pow(waterLevel - y1, 2));
                } else { // p2在水下
                    area += (x2 - ix) * (waterLevel - y2) / 2;
                    bedPerimeter += Math.sqrt(Math.pow(x2 - ix, 2) + Math.pow(waterLevel - y2, 2));
                }
            }
        }
        
        // 确保交点按X坐标排序
        intersectionPoints.sort((a, b) => a.x - b.x);
        return { area, bedPerimeter, intersectionPoints };
    }
    
    /**
     * 为坐标轴计算一个“友好”的数字，用于刻度间距。
     * @param {number} range - 数据的范围 (max - min)。
     * @param {boolean} round - 是否进行四舍五入。
     * @returns {number} - 计算出的友好数字。
     */
    function calculateNiceNumber(range, round) {
        const exponent = Math.floor(Math.log10(range));
        const fraction = range / Math.pow(10, exponent);
        let niceFraction;

        if (round) {
            if (fraction < 1.5) niceFraction = 1;
            else if (fraction < 3) niceFraction = 2;
            else if (fraction < 7) niceFraction = 5;
            else niceFraction = 10;
        } else {
            if (fraction <= 1) niceFraction = 1;
            else if (fraction <= 2) niceFraction = 2;
            else if (fraction <= 5) niceFraction = 5;
            else niceFraction = 10;
        }
        return niceFraction * Math.pow(10, exponent);
    }

    /**
     * 计算坐标轴的参数（最小值、最大值、刻度间距）。
     * @param {number} min - 数据的最小值。
     * @param {number} max - 数据的最大值。
     * @returns {Object} - 包含 {min, max, tickSpacing} 的对象。
     */
    function calculateAxisParameters(min, max) {
        if (min === max) {
            min -= 1;
            max += 1;
        }
        const range = calculateNiceNumber(max - min, false);
        const tickSpacing = calculateNiceNumber(range / 8, true); // 期望大约8个刻度
        const niceMin = Math.floor(min / tickSpacing) * tickSpacing;
        const niceMax = Math.ceil(max / tickSpacing) * tickSpacing;
        return { min: niceMin, max: niceMax, tickSpacing: tickSpacing };
    }

    // =================================================================================
    // 3. 绘图与UI更新函数 (Drawing & UI Update Functions)
    //    这些函数负责将数据显示在Canvas和HTML元素上。
    // =================================================================================

    /**
     * 绘制断面图。
     * @param {number|null} currentWaterLevel - 当前要绘制的水位，或null。
     * @param {Object|null} selectedData - 选中的那一行结果的数据，用于显示参数。
     */
    function drawCrossSection(currentWaterLevel = null, selectedData = null) {
        // ... 函数体在主程序入口部分定义，因为它需要访问Canvas上下文 ...
    }

    /**
     * 更新水位流量关系图 (Q-H Plot)。
     */
    function updateQHPlot() {
        // ... 函数体在主程序入口部分定义，因为它需要访问Canvas上下文 ...
    }
    
    /**
     * 更新岸顶信息显示。
     */
    function updateBankPointInfo() {
        // ... 函数体在主程序入口部分定义，因为它需要访问DOM元素 ...
    }
    
    /**
     * 设置并显示状态消息。
     * @param {string} message - 要显示的消息文本。
     * @param {boolean} isError - 是否为错误消息。
     */
    function setStatusMessage(message, isError = false) {
        // ... 函数体在主程序入口部分定义，因为它需要访问DOM元素 ...
    }

    // =================================================================================
    // 4. 历史记录管理 (History Management - LocalStorage)
    //    这组函数负责处理断面的本地保存、加载和删除。
    // =================================================================================

    /**
     * 从 localStorage 获取所有已保存的断面。
     * @returns {Array<{name: string, data: string}>}
     */
    function getSavedSections() {
        try {
            const sectionsJSON = localStorage.getItem(STORAGE_KEY);
            const sections = sectionsJSON ? JSON.parse(sectionsJSON) : [];
            return Array.isArray(sections) ? sections : [];
        } catch (e) {
            console.error("解析历史断面数据失败:", e);
            return [];
        }
    }

    /**
     * 保存或更新一个断面。
     * @param {string} name - 断面名称。
     * @param {string} data - 断面数据。
     */
    function saveSection(name, data) {
        const sections = getSavedSections();
        const existingIndex = sections.findIndex(s => s.name === name);
        if (existingIndex > -1) {
            sections[existingIndex].data = data;
        } else {
            sections.push({ name, data });
        }
        localStorage.setItem(STORAGE_KEY, JSON.stringify(sections));
    }

    /**
     * 根据名称删除一个断面。
     * @param {string} name - 要删除的断面名称。
     */
    function deleteSection(name) {
        let sections = getSavedSections();
        sections = sections.filter(s => s.name !== name);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(sections));
    }
    
    /**
     * 渲染历史断面列表到自定义的下拉菜单中。
     */
    function renderSavedSections() {
        // ... 函数体在主程序入口部分定义，因为它需要访问DOM元素 ...
    }
    
    // =================================================================================
    // 5. 数据查询函数 (Data Query Functions)
    //    这部分函数用于实现结果的内插查询功能。
    // =================================================================================

    /**
     * 线性内插计算。
     * @param {number} x - 目标点。
     * @param {number} x1 - 已知点1的x值。
     * @param {number} y1 - 已知点1的y值。
     * @param {number} x2 - 已知点2的x值。
     * @param {number} y2 - 已知点2的y值。
     * @returns {number} - 内插计算出的y值。
     */
    function linearInterpolate(x, x1, y1, x2, y2) {
        if (x2 === x1) return y1; // 避免除以零
        return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
    }

    /**
     * 在数据集中查找用于内插的点。
     * @param {number} value - 要查询的值。
     * @param {Array<Object>} data - 数据集。
     * @param {string} valueKey - 查询值在数据对象中的键。
     * @param {string} targetKey - 目标值在数据对象中的键。
     * @returns {Object|null} - 返回插值所需的信息或null。
     */
    function findInterpolationPoints(value, data, valueKey, targetKey) {
        if (data.length < 2) return null;
        data.sort((a, b) => a[valueKey] - b[valueKey]);
        
        if (value < data[0][valueKey] || value > data[data.length - 1][valueKey]) return null;
        
        for (let i = 0; i < data.length - 1; i++) {
            if (value >= data[i][valueKey] && value <= data[i + 1][valueKey]) {
                return {
                    lower: data[i],
                    upper: data[i + 1]
                };
            }
        }
        return null;
    }
    
    // =================================================================================
    // 6. 事件处理函数 (Event Handlers)
    //    这些函数直接由用户的操作（如点击按钮）触发。
    // =================================================================================

    /**
     * 处理“预览/更新断面”按钮点击事件。
     */
    function handleUpdatePreview() {
        // ... 函数体在主程序入口部分定义 ...
    }
    
    /**
     * 处理“计算”按钮点击事件。
     */
    function handleCalculate() {
        // ... 函数体在主程序入口部分定义 ...
    }

    /**
     * 处理“保存当前断面”按钮点击事件。
     */
    function handleSaveSection() {
        // ... 函数体在主程序入口部分定义 ...
    }

    /**
     * 处理结果表格行点击事件。
     * @param {Event} event - 点击事件对象。
     */
    function handleTableRowClick(event) {
        // ... 函数体在主程序入口部分定义 ...
    }

    /**
     * 处理“通过水位查询流量”的逻辑。
     */
    function handleWaterLevelQuery() {
        // ... 函数体在主程序入口部分定义 ...
    }

    /**
     * 处理“通过流量查询水位”的逻辑。
     */
    function handleFlowQuery() {
        // ... 函数体在主程序入口部分定义 ...
    }

    /**
     * 复制结果到剪贴板。
     */
    function copyResultsToClipboard() {
        // ... 函数体在主程序入口部分定义 ...
    }
    
    /**
     * 调整岸顶点的位置。
     * @param {string} side - 'left' 或 'right'。
     * @param {number} direction - -1 (左移) 或 1 (右移)。
     */
    function adjustBankPoint(side, direction) {
        // ... 函数体在主程序入口部分定义 ...
    }


    // =================================================================================
    // 7. 主程序入口 (Main Execution Block)
    //    使用 DOMContentLoaded 确保所有HTML元素加载完毕后才执行脚本。
    // =================================================================================
    document.addEventListener('DOMContentLoaded', () => {

        // --------------------------------------------------
        // 7.1 DOM元素常量定义
        // --------------------------------------------------
        const canvas = document.getElementById('crossSectionCanvas');
        const ctx = canvas.getContext('2d');
        const qhCanvas = document.getElementById('qhCanvas');
        const qhCtx = qhCanvas.getContext('2d');

        // 输入元素
        const sectionDataEl = document.getElementById('sectionData');
        const waterLevelIntervalEl = document.getElementById('waterLevelInterval');
        const manningN_mc_El = document.getElementById('manningN_mc');
        const manningN_lfp_El = document.getElementById('manningN_lfp');
        const manningN_rfp_El = document.getElementById('manningN_rfp');
        const channelSlopeEl = document.getElementById('channelSlope');

        // 选项复选框和相关容器
        const useManualWaterLevelsEl = document.getElementById('useManualWaterLevels');
        const manualWaterLevelControlsEl = document.getElementById('manualWaterLevelControls');
        const manualStartWLEl = document.getElementById('manualStartWL');
        const manualEndWLEl = document.getElementById('manualEndWL');
        const considerFloodplainEl = document.getElementById('considerFloodplain');
        const floodplainControlsEl = document.getElementById('floodplainControls');

        // 信息显示元素
        const leftBankInfoEl = document.getElementById('leftBankInfo');
        const rightBankInfoEl = document.getElementById('rightBankInfo');
        const statusMessageEl = document.getElementById('statusMessage');
        const noResultsMessageEl = document.getElementById('noResultsMessage');
        const resultsTableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
        const parameterDisplay = document.getElementById('parameterDisplay');
        const paramAreaEl = document.getElementById('paramArea');
        const paramPerimeterEl = document.getElementById('paramPerimeter');
        const paramFlowEl = document.getElementById('paramFlow');
        const queryResultTextEl = document.getElementById('queryResultText');
        
        // 历史记录下拉菜单
        const historyDropdownButton = document.getElementById('historyDropdownButton');
        const historyDropdownPanel = document.getElementById('historyDropdownPanel');
        const historyDropdownLabel = document.getElementById('historyDropdownLabel');

        // 更新记录模态框
        const showChangelogBtn = document.getElementById('showChangelogBtn');
        const closeChangelogBtn = document.getElementById('closeChangelogBtn');
        const changelogModal = document.getElementById('changelogModal');

        // 保存断面模态框
        const saveSectionModal = document.getElementById('saveSectionModal');
        const saveSectionTitle = document.getElementById('saveSectionTitle');
        const saveSectionDescription = document.getElementById('saveSectionDescription');
        const nameInputGroup = document.getElementById('nameInputGroup');
        const nameInputNotification = document.getElementById('nameInputNotification');
        const OverwriteBtn = document.getElementById('OverwriteBtn');
        const SaveBtn = document.getElementById('SaveBtn');
        const SaveAsNewBtn = document.getElementById('SaveAsNewBtn');
        const sectionNameInput = document.getElementById('sectionNameInput');
        const CancelSaveBtn = document.getElementById('CancelSaveBtn');

        // 删除断面模态框
        const deleteConfirmModal = document.getElementById('deleteConfirmModal');
        const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
        const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
        const sectionNameToDelete = document.getElementById('sectionNameToDelete');


        // --------------------------------------------------
        // 7.2 函数具体实现 (因为它们需要访问上面的DOM常量)
        // --------------------------------------------------

        // --- UI更新函数的具体实现 ---
        setStatusMessage = function(message, isError = false) {
            statusMessageEl.textContent = message;
            statusMessageEl.className = 'mt-2 p-3 rounded-md text-sm'; // 重置类
            statusMessageEl.classList.add(isError ? 'error' : 'success');
        }

        // --- 更新岸顶点信息函数的具体实现 ---
        updateBankPointInfo = function() {
            const ptL = (leftBankPointIndex !== -1 && parsedSectionPoints[leftBankPointIndex]) ? parsedSectionPoints[leftBankPointIndex] : null;
            const ptR = (rightBankPointIndex !== -1 && parsedSectionPoints[rightBankPointIndex]) ? parsedSectionPoints[rightBankPointIndex] : null;

            leftBankInfoEl.textContent = ptL ? `X:${ptL.x.toFixed(2)}, Y:${ptL.y.toFixed(2)} (点 ${leftBankPointIndex})` : '-';
            rightBankInfoEl.textContent = ptR ? `X:${ptR.x.toFixed(2)}, Y:${ptR.y.toFixed(2)} (点 ${rightBankPointIndex})` : '-';
        }


        // --- 绘图函数的具体实现 ---
        drawCrossSection = function(currentWaterLevel = null, selectedData = null) {
            if (parsedSectionPoints.length < 2) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const padding = 60;
            const viewWidth = canvas.width / dpr - 2 * padding;
            const viewHeight = canvas.height / dpr - 2 * padding;

            const minX_data = parsedSectionPoints[0].x;
            const maxX_data = parsedSectionPoints[parsedSectionPoints.length - 1].x;
            let minY_data = Math.min(...parsedSectionPoints.map(p => p.y));
            let maxY_data = Math.max(...parsedSectionPoints.map(p => p.y));

            let plotMinY = minY_data;
            let plotMaxY = maxY_data;
            if (currentWaterLevel !== null) plotMaxY = Math.max(plotMaxY, currentWaterLevel);

            if (considerFloodplainEl.checked) {
                if (leftBankPointIndex > -1) plotMaxY = Math.max(plotMaxY, parsedSectionPoints[leftBankPointIndex].y);
                if (rightBankPointIndex > -1) plotMaxY = Math.max(plotMaxY, parsedSectionPoints[rightBankPointIndex].y);
                if (hBankfull > -1) plotMaxY = Math.max(plotMaxY, hBankfull);
            }

            const yBuffer = Math.max((plotMaxY - plotMinY) * 0.1, 0.1);
            plotMinY -= yBuffer;
            plotMaxY += yBuffer;

            if (Math.abs(plotMaxY - plotMinY) < 1e-4) { plotMinY -= 1; plotMaxY += 1; }
            
            const xAxisParams = calculateAxisParameters(minX_data, maxX_data);
            const yAxisParams = calculateAxisParameters(plotMinY, plotMaxY);
            
            const toCanvasX = (worldX) => padding + (worldX - xAxisParams.min) * (viewWidth / (xAxisParams.max - xAxisParams.min || 1));
            const toCanvasY = (worldY) => canvas.height / dpr - padding - (worldY - yAxisParams.min) * (viewHeight / (yAxisParams.max - yAxisParams.min || 1));
            
             // 绘制网格线
            ctx.beginPath();
            ctx.strokeStyle = '#f0f9ff'; //更淡的蓝色
            ctx.lineWidth = 1;
            for (let x = xAxisParams.min; x <= xAxisParams.max; x += xAxisParams.tickSpacing) {
                const cx = toCanvasX(x);
                ctx.moveTo(cx, padding);
                ctx.lineTo(cx, canvas.height/dpr - padding);
            }
            for (let y = yAxisParams.min; y <= yAxisParams.max; y += yAxisParams.tickSpacing) {
                const cy = toCanvasY(y);
                ctx.moveTo(padding, cy);
                ctx.lineTo(canvas.width/dpr - padding, cy);
            }
            ctx.stroke();

            // 绘制坐标轴
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height/dpr - padding);
            ctx.lineTo(canvas.width/dpr - padding, canvas.height/dpr - padding);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height/dpr - padding);
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // 绘制标签
            ctx.fillStyle = '#4b5563';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            for (let x = xAxisParams.min; x <= xAxisParams.max; x += xAxisParams.tickSpacing) {
                ctx.fillText(x.toFixed(1), toCanvasX(x), canvas.height/dpr - padding + 20);
            }
             ctx.textAlign = "right";
            for (let y = yAxisParams.min; y <= yAxisParams.max; y += yAxisParams.tickSpacing) {
                ctx.fillText(y.toFixed(2), padding - 8, toCanvasY(y) + 4);
            }
            ctx.save();
            ctx.translate(padding - 45, canvas.height / dpr / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.fillText("高程 (m)", 0, 0);
            ctx.restore();
            ctx.textAlign = "center";
            ctx.fillText("距离 (m)", canvas.width / dpr / 2, canvas.height/dpr - padding + 40);


            // 绘制断面线和填充
            ctx.beginPath();
            ctx.moveTo(toCanvasX(parsedSectionPoints[0].x), toCanvasY(parsedSectionPoints[0].y));
            parsedSectionPoints.forEach(p => ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y)));
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.lineTo(toCanvasX(parsedSectionPoints[parsedSectionPoints.length - 1].x), canvas.height/dpr - padding);
            ctx.lineTo(toCanvasX(parsedSectionPoints[0].x), canvas.height/dpr - padding);
            ctx.closePath();
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.fill();

            // 绘制点
            parsedSectionPoints.forEach((p, index) => {
                ctx.beginPath();
                ctx.arc(toCanvasX(p.x), toCanvasY(p.y), 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#3b82f6';
                ctx.stroke();
            });

            // 绘制岸顶点
            if (considerFloodplainEl.checked) {
                [leftBankPointIndex, rightBankPointIndex].forEach(index => {
                    if (index > -1 && parsedSectionPoints[index]) {
                        const p = parsedSectionPoints[index];
                        ctx.beginPath();
                        ctx.arc(toCanvasX(p.x), toCanvasY(p.y), 6, 0, 2 * Math.PI);
                        ctx.fillStyle = '#ef4444';
                        ctx.fill();
                    }
                });
            }

            // 绘制水位线和水域填充
            if (currentWaterLevel !== null && selectedData && selectedData.intersectionPoints) {
                const waterY = toCanvasY(currentWaterLevel);
                ctx.beginPath();
                ctx.moveTo(padding, waterY);
                ctx.lineTo(canvas.width/dpr - padding, waterY);
                ctx.strokeStyle = '#06b6d4';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 填充水域
                const ips = selectedData.intersectionPoints;
                if (ips.length >= 2) {
                     ctx.beginPath();
                     ctx.moveTo(toCanvasX(ips[0].x), toCanvasY(ips[0].y));
                     for (const p of parsedSectionPoints) {
                         if (p.x > ips[0].x && p.x < ips[ips.length - 1].x) {
                             ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
                         }
                     }
                     ctx.lineTo(toCanvasX(ips[ips.length - 1].x), toCanvasY(ips[ips.length - 1].y));
                     ctx.closePath();
                     ctx.fillStyle = 'rgba(6, 182, 212, 0.3)';
                     ctx.fill();
                }
            }

            // 显示参数
            parameterDisplay.classList.toggle('hidden', !selectedData);
            if(selectedData){
                paramAreaEl.textContent = selectedData.a;
                paramPerimeterEl.textContent = selectedData.p;
                paramFlowEl.textContent = selectedData.q;
            }
        }


        /**
         * 更新水位流量关系图 (Q-H Plot)。
         */ 
        updateQHPlot = function() {
            if (resultsData.length === 0) {
                 qhCtx.clearRect(0, 0, qhCanvas.width, qhCanvas.height);
                 return;
            }
            const dpr = window.devicePixelRatio || 1;
            const rect = qhCanvas.getBoundingClientRect();
            qhCanvas.width = rect.width * dpr;
            qhCanvas.height = rect.height * dpr;
            qhCtx.scale(dpr, dpr);
            qhCtx.clearRect(0, 0, qhCanvas.width, qhCanvas.height);

            const data = resultsData.map(d => ({ q: parseFloat(d.q), h: parseFloat(d.wl) }));
            const padding = 60;
            const viewWidth = qhCanvas.width / dpr - 2 * padding;
            const viewHeight = qhCanvas.height / dpr - 2 * padding;

            const qMin = Math.min(...data.map(d => d.q));
            const qMax = Math.max(...data.map(d => d.q));
            const hMin = Math.min(...data.map(d => d.h));
            const hMax = Math.max(...data.map(d => d.h));

            const xAxisParams = calculateAxisParameters(qhPlotConfig.xAxis.min ?? qMin, qhPlotConfig.xAxis.max ?? qMax);
            const yAxisParams = calculateAxisParameters(qhPlotConfig.yAxis.min ?? hMin, qhPlotConfig.yAxis.max ?? hMax);

            const toCanvasX = (worldX) => padding + (worldX - xAxisParams.min) * (viewWidth / (xAxisParams.max - xAxisParams.min || 1));
            const toCanvasY = (worldY) => qhCanvas.height / dpr - padding - (worldY - yAxisParams.min) * (viewHeight / (yAxisParams.max - yAxisParams.min || 1));

            // ... (绘图代码与 drawCrossSection 类似) ...
             // 网格
            qhCtx.beginPath();
            qhCtx.strokeStyle = '#f0f9ff';
            qhCtx.lineWidth = 1;
            for (let x = xAxisParams.min; x <= xAxisParams.max; x += xAxisParams.tickSpacing) {
                if(xAxisParams.tickSpacing === 0) break;
                qhCtx.moveTo(toCanvasX(x), padding);
                qhCtx.lineTo(toCanvasX(x), qhCanvas.height / dpr - padding);
            }
            for (let y = yAxisParams.min; y <= yAxisParams.max; y += yAxisParams.tickSpacing) {
                if(yAxisParams.tickSpacing === 0) break;
                qhCtx.moveTo(padding, toCanvasY(y));
                qhCtx.lineTo(qhCanvas.width / dpr - padding, toCanvasY(y));
            }
            qhCtx.stroke();
            
            // 坐标轴
            qhCtx.beginPath();
            qhCtx.strokeStyle = '#9ca3af';
            qhCtx.lineWidth = 1.5;
            qhCtx.moveTo(padding, qhCanvas.height/dpr - padding);
            qhCtx.lineTo(qhCanvas.width/dpr - padding, qhCanvas.height/dpr - padding);
            qhCtx.moveTo(padding, padding);
            qhCtx.lineTo(padding, qhCanvas.height/dpr - padding);
            qhCtx.stroke();

            // 标签
            qhCtx.fillStyle = '#4b5563';
            qhCtx.font = '12px Inter';
            qhCtx.textAlign = 'center';
             for (let x = xAxisParams.min; x <= xAxisParams.max; x += xAxisParams.tickSpacing) {
                 if(xAxisParams.tickSpacing === 0) break;
                qhCtx.fillText(x.toFixed(2), toCanvasX(x), qhCanvas.height/dpr - padding + 20);
            }
             qhCtx.textAlign = "right";
            for (let y = yAxisParams.min; y <= yAxisParams.max; y += yAxisParams.tickSpacing) {
                if(yAxisParams.tickSpacing === 0) break;
                qhCtx.fillText(y.toFixed(2), padding - 8, toCanvasY(y) + 4);
            }
            // 轴标题
            qhCtx.save();
            qhCtx.translate(padding - 45, qhCanvas.height / dpr / 2);
            qhCtx.rotate(-Math.PI / 2);
            qhCtx.textAlign = "center";
            qhCtx.fillText("水位 (m)", 0, 0);
            qhCtx.restore();
            qhCtx.textAlign = "center";
            qhCtx.fillText("流量 (m³/s)", qhCanvas.width / dpr / 2, qhCanvas.height/dpr - padding + 40);

            // 曲线
            qhCtx.beginPath();
            qhCtx.strokeStyle = '#3b82f6';
            qhCtx.lineWidth = 2;
            data.forEach((d, i) => {
                if (i === 0) qhCtx.moveTo(toCanvasX(d.q), toCanvasY(d.h));
                else qhCtx.lineTo(toCanvasX(d.q), toCanvasY(d.h));
            });
            qhCtx.stroke();
            
            // 数据点
             if (qhPlotConfig.showPoints) {
                data.forEach(d => {
                    qhCtx.beginPath();
                    qhCtx.arc(toCanvasX(d.q), toCanvasY(d.h), 3, 0, 2 * Math.PI);
                    qhCtx.fillStyle = '#3b82f6';
                    qhCtx.fill();
                });
            }      
        }


        // --- 历史记录UI函数的具体实现 ---
        renderSavedSections = function() {
            const sections = getSavedSections();
            panelEl = historyDropdownPanel;
            panelEl.innerHTML = ''; 

            if (sections.length === 0) {
                panelEl.innerHTML = '<div class="px-4 py-2 text-sm text-gray-500">暂无历史记录</div>';
                return;
            }
            sections.forEach(section => {
                const itemEl = document.createElement('div');
                itemEl.className = 'flex justify-between items-center px-4 py-2 text-sm text-gray-700 hover:bg-blue-50 cursor-pointer';
                itemEl.innerHTML = `<span>${section.name}</span><button class="w-5 h-5 flex items-center justify-center rounded-full text-gray-400 hover:bg-red-200 hover:text-red-700" title="删除">&times;</button>`;
                
                itemEl.addEventListener('click', () => {
                    sectionDataEl.value = section.data;
                    historyDropdownLabel.textContent = section.name;
                    historyDropdownLabel.classList.remove('text-gray-500');
                    panelEl.classList.add('hidden');
                    activeSectionName = section.name; // 记录当前选中的断面名称
                    handleUpdatePreview();
                });

                itemEl.querySelector('button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    // 保存要删除的断面名称，并在模态框中显示
                    sectionNameToDeleteState = section.name;
                    sectionNameToDelete.textContent = section.name;
                    deleteConfirmModal.classList.remove('hidden');             
                });
                panelEl.appendChild(itemEl);
            });
        }


        // 显示保存断面模态框
        function showSaveSectionModal(isOverwrite) {
            /*
            isOverwrite=true: 覆盖模式
            isOverwrite=false: 新建模式
            */
            if(isOverwrite) {
                // 覆盖模式
                saveSectionTitle.textContent = '保存修改';
                saveSectionDescription.textContent = `当前断面为 “${activeSectionName}”，请选择是否覆盖`;

                nameInputGroup.classList.add('hidden');
                OverwriteBtn.classList.remove('hidden');
                SaveAsNewBtn.classList.remove('hidden');
                SaveBtn.classList.add('hidden');
            } else {
                // 新建模式
                saveSectionTitle.textContent = '保存新断面';
                saveSectionDescription.textContent = '请输入断面名称';

                nameInputGroup.classList.remove('hidden');
                OverwriteBtn.classList.add('hidden');
                SaveAsNewBtn.classList.add('hidden');
                SaveBtn.classList.remove('hidden');
            }
            saveSectionModal.classList.remove('hidden');
            sectionNameInput.value = ''; // 清空输入框
            sectionNameInput.focus(); // 聚焦到输入框
        }


        // 保存断面
        handleSaveSection = function() {
            // 初始化
            sectionNameInput.value = '';
            nameInputNotification.textContent = '';

            const currentData = sectionDataEl.value.trim();
            if (!currentData) {
                setStatusMessage('断面数据为空，无法保存。', true);
                return;
            }

            // --- 核心逻辑判断 ---
            if (activeSectionName) {
                // 如果当前有活动的断面，说明是编辑模式，显示保存断面模态框
                showSaveSectionModal(true);
            } else {
                // 否则，是新建模式，显示保存断面模态框
                showSaveSectionModal(false);
            }
        }
        

        // --- 事件处理函数的具体实现 ---
        handleUpdatePreview = function() {
            const data = sectionDataEl.value.trim();
            if (!data) {
                setStatusMessage('断面数据不能为空。', true);
                parsedSectionPoints = []; 
                drawCrossSection();
                return;
            }
            const lines = data.split('\n');
            const tempPoints = [];
            for (let i = 0; i < lines.length; i++) {
                const parts = lines[i].trim().split(/[\s,]+/);
                if (parts.length === 2) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    if (!isNaN(x) && !isNaN(y)) {
                        tempPoints.push({ x, y, originalIndex: i });
                    } else {
                        setStatusMessage(`数据格式错误在行 ${i+1}: "${lines[i]}"`, true);
                        return;
                    }
                } else if (lines[i].trim() !== "") { 
                     setStatusMessage(`数据格式错误在行 ${i+1}: "${lines[i]}" (应为 X Y)`, true);
                    return;
                }
            }

            if (tempPoints.length < 2) {
                setStatusMessage('断面数据至少需要两个点。', true);
                return;
            }

            parsedSectionPoints = tempPoints.sort((a, b) => a.x - b.x);
            setStatusMessage('断面预览已更新。', false);
            drawCrossSection();
        }


        handleCalculate = function() {
            handleUpdatePreview(); // 先确保数据是最新的
            if (parsedSectionPoints.length < 2) return;
            

            // 1. 获取和验证计算参数
            // 如果用户没有输入值，则使用placeholder中的默认值
            const waterLevelStep = parseFloat(waterLevelIntervalEl.value) || parseFloat(waterLevelIntervalEl.placeholder);
            const n_mc_val = parseFloat(manningN_mc_El.value) || parseFloat(manningN_mc_El.placeholder);
            const i_val = parseFloat(channelSlopeEl.value) || parseFloat(channelSlopeEl.placeholder);
            if (isNaN(waterLevelStep) || waterLevelStep <= 0) { setStatusMessage('无效的水位间隔。', true); return; }
            if (isNaN(n_mc_val) || n_mc_val <= 0) { setStatusMessage('无效的曼宁糙率系数。', true); return; }
            if (isNaN(i_val) || i_val <= 0) { setStatusMessage('无效的河道坡降。', true); return; }
            
            // 2. 确定水位计算范围
            let startWL, endWL;
            if (useManualWaterLevelsEl.checked) {
                startWL = parseFloat(manualStartWLEl.value);
                endWL = parseFloat(manualEndWLEl.value);
                if (isNaN(startWL) || isNaN(endWL) || startWL >= endWL) {
                    setStatusMessage('手动设定的水位范围无效。', true);
                    return;
                }
            } else {
                const minY_data = Math.min(...parsedSectionPoints.map(p => p.y));
                const maxY_data = Math.max(...parsedSectionPoints.map(p => p.y));
                startWL = minY_data;
                endWL = maxY_data;
            }

            // 3. 计算临界岸顶高程
            hBankfull = -1;
            if (considerFloodplainEl.checked && leftBankPointIndex !== -1 && rightBankPointIndex !== -1) {
                const leftBankPoint = parsedSectionPoints[leftBankPointIndex];
                const rightBankPoint = parsedSectionPoints[rightBankPointIndex];
                hBankfull = Math.min(leftBankPoint.y, rightBankPoint.y);
            }

            // 4. 循环计算
            resultsData = [];
            resultsTableBody.innerHTML = '';
            for (let currentWL = startWL; currentWL <= endWL; currentWL += waterLevelStep) {
                let A_final = 0, P_final = 0, R_final = 0, Q_final = 0;
                let remark = "-";
                let allIntersectionPoints = [];
                const currentWLFixed = parseFloat(currentWL.toFixed(5));

                if (!considerFloodplainEl.checked || hBankfull === -1) { // 简单河道
                    const geom = calculateGeometricProperties(parsedSectionPoints, currentWLFixed);
                    A_final = geom.area;
                    P_final = geom.bedPerimeter;
                    allIntersectionPoints = geom.intersectionPoints;
                } else { // 复式断面
                    remark = currentWLFixed > hBankfull ? "漫滩" : "主槽";
                    const n_lfp_val = parseFloat(manningN_lfp_El.value) || n_mc_val;
                    const n_rfp_val = parseFloat(manningN_rfp_El.value) || n_mc_val;
                    
                    const points_mc = parsedSectionPoints.slice(leftBankPointIndex, rightBankPointIndex + 1);
                    const points_lfp = parsedSectionPoints.slice(0, leftBankPointIndex + 1);
                    const points_rfp = parsedSectionPoints.slice(rightBankPointIndex);

                    const geom_mc = calculateGeometricProperties(points_mc, currentWLFixed);
                    const geom_lfp = calculateGeometricProperties(points_lfp, currentWLFixed);
                    const geom_rfp = calculateGeometricProperties(points_rfp, currentWLFixed);

                    const A_mc = geom_mc.area, P_mc = geom_mc.bedPerimeter;
                    const A_lfp = geom_lfp.area, P_lfp = geom_lfp.bedPerimeter;
                    const A_rfp = geom_rfp.area, P_rfp = geom_rfp.bedPerimeter;

                    const R_mc = P_mc > 0 ? A_mc / P_mc : 0;
                    const R_lfp = P_lfp > 0 ? A_lfp / P_lfp : 0;
                    const R_rfp = P_rfp > 0 ? A_rfp / P_rfp : 0;

                    const Q_mc = (1/n_mc_val) * A_mc * Math.pow(R_mc, 2/3) * Math.pow(i_val, 1/2);
                    const Q_lfp = (1/n_lfp_val) * A_lfp * Math.pow(R_lfp, 2/3) * Math.pow(i_val, 1/2);
                    const Q_rfp = (1/n_rfp_val) * A_rfp * Math.pow(R_rfp, 2/3) * Math.pow(i_val, 1/2);
                    
                    A_final = A_mc + A_lfp + A_rfp;
                    Q_final = Q_mc + Q_lfp + Q_rfp;
                    P_final = P_mc + P_lfp + P_rfp;
                    allIntersectionPoints = [...geom_lfp.intersectionPoints, ...geom_mc.intersectionPoints, ...geom_rfp.intersectionPoints]
                                            .sort((a, b) => a.x - b.x);
                }

                if (A_final > 0) {
                    R_final = P_final > 0 ? A_final / P_final : 0;
                    if (!considerFloodplainEl.checked || hBankfull === -1) {
                         Q_final = (1 / n_mc_val) * A_final * Math.pow(R_final, 2/3) * Math.pow(i_val, 1/2);
                    }
                    resultsData.push({
                        wl: currentWLFixed.toFixed(3),
                        a: A_final.toFixed(3),
                        p: P_final.toFixed(3),
                        r: R_final.toFixed(3),
                        q: Q_final.toFixed(3),
                        rem: remark,
                        intersectionPoints: allIntersectionPoints
                    });
                }
            }
 
            // 5. 渲染结果
            if (resultsData.length > 0) {
                resultsData.forEach(data => {
                    const row = resultsTableBody.insertRow();
                    row.addEventListener('click', handleTableRowClick);
                    row.insertCell().textContent = data.wl;
                    row.insertCell().textContent = data.a;
                    row.insertCell().textContent = data.p;
                    row.insertCell().textContent = data.r;
                    row.insertCell().textContent = data.q;
                    const remarkCell = row.insertCell();
                    remarkCell.textContent = data.rem;
                    remarkCell.className = data.rem === "漫滩" ? 'remark-flood' : 'remark-main';
                });
                noResultsMessageEl.classList.add('hidden');
                setStatusMessage(`计算完成，共 ${resultsData.length} 条结果。`, false);
                if (resultsTableBody.rows[0]) resultsTableBody.rows[0].click(); // 默认选中第一行
                updateQHPlot(); // 更新Q-H图
            } else {
                noResultsMessageEl.classList.remove('hidden');
                setStatusMessage('在设定范围内无有效计算结果。', true);
            }
        }

        handleTableRowClick = function(event) {
            const row = event.currentTarget;
            Array.from(resultsTableBody.rows).forEach(r => r.classList.remove('selected'));
            row.classList.add('selected');
            
            const rowIndex = row.rowIndex - 1; // 减去表头
            const selectedData = resultsData[rowIndex];
            
            drawCrossSection(parseFloat(selectedData.wl), selectedData);
        }

        handleWaterLevelQuery = function() {
            // ... (与您原文件逻辑一致) ...
            const waterLevel = parseFloat(document.getElementById('queryWaterLevel').value);
            if (isNaN(waterLevel) || resultsData.length < 2) return;
            const data = resultsData.map(d => ({ h: parseFloat(d.wl), q: parseFloat(d.q) }));
            const points = findInterpolationPoints(waterLevel, data, 'h', 'q');
            if (!points) {
                queryResultTextEl.textContent = '超出计算范围';
            } else {
                const flow = linearInterpolate(waterLevel, points.lower.h, points.lower.q, points.upper.h, points.upper.q);
                queryResultTextEl.innerHTML = `流量: <span class="text-red-600 font-medium">${flow.toFixed(3)}</span> m³/s (内插)`;
            }
            queryResultTextEl.classList.remove('hidden');
        }

        handleFlowQuery = function() {
            // ... (与您原文件逻辑一致) ...
             const flow = parseFloat(document.getElementById('queryFlow').value);
            if (isNaN(flow) || resultsData.length < 2) return;
            const data = resultsData.map(d => ({ q: parseFloat(d.q), h: parseFloat(d.wl) }));
            const points = findInterpolationPoints(flow, data, 'q', 'h');
             if (!points) {
                queryResultTextEl.textContent = '超出计算范围';
            } else {
                const level = linearInterpolate(flow, points.lower.q, points.lower.h, points.upper.q, points.upper.h);
                queryResultTextEl.innerHTML = `水位: <span class="text-red-600 font-medium">${level.toFixed(3)}</span> m (内插)`;
            }
            queryResultTextEl.classList.remove('hidden');
        }

        copyResultsToClipboard = function() {
            if (resultsTableBody.rows.length === 0) {
                setStatusMessage('没有结果可以复制。', true);
                return;
            }
            const header = Array.from(document.querySelectorAll('#resultsTable th')).map(th => th.textContent).join('\t');
            const data = Array.from(resultsTableBody.rows).map(row => 
                Array.from(row.cells).map(cell => cell.textContent).join('\t')
            ).join('\n');
            navigator.clipboard.writeText(header + '\n' + data).then(() => {
                setStatusMessage('结果已复制到剪贴板。', false);
            }).catch(err => {
                setStatusMessage('复制失败: ' + err, true);
            });
        }
        
        adjustBankPoint = function(side, direction) {
            if (!considerFloodplainEl.checked || parsedSectionPoints.length === 0) return;
            
            if (side === 'left') {
                const newIndex = leftBankPointIndex + direction;
                if (newIndex >= 0 && newIndex < rightBankPointIndex) {
                    leftBankPointIndex = newIndex;
                }
            } else { // right
                const newIndex = rightBankPointIndex + direction;
                if (newIndex < parsedSectionPoints.length && newIndex > leftBankPointIndex) {
                    rightBankPointIndex = newIndex;
                }
            }
            updateBankPointInfo();
            drawCrossSection(); // 重绘以显示新的岸顶点
        }


        // --------------------------------------------------
        // 7.3 事件监听器绑定
        // --------------------------------------------------
        
        // 主要功能按钮
        document.getElementById('updatePreviewButton').addEventListener('click', handleUpdatePreview);
        document.getElementById('calculateButton').addEventListener('click', handleCalculate);
        document.getElementById('saveSectionButton').addEventListener('click', handleSaveSection);
        document.getElementById('copyResultsButton').addEventListener('click', copyResultsToClipboard);
        
        // 岸顶调整按钮
        document.getElementById('leftBankPrev').addEventListener('click', () => adjustBankPoint('left', -1));
        document.getElementById('leftBankNext').addEventListener('click', () => adjustBankPoint('left', 1));
        document.getElementById('rightBankPrev').addEventListener('click', () => adjustBankPoint('right', -1));
        document.getElementById('rightBankNext').addEventListener('click', () => adjustBankPoint('right', 1));
        
        // 查询功能
        document.getElementById('queryFlowByLevel').addEventListener('click', handleWaterLevelQuery);
        document.getElementById('queryLevelByFlow').addEventListener('click', handleFlowQuery);
        document.getElementById('queryWaterLevel').addEventListener('keypress', (e) => e.key === 'Enter' && handleWaterLevelQuery());
        document.getElementById('queryFlow').addEventListener('keypress', (e) => e.key === 'Enter' && handleFlowQuery());

        
        /* ========================= 保存断面模态框的交互======================= */
        OverwriteBtn.addEventListener('click', () => {
            const currentData = sectionDataEl.value.trim();
            if (activeSectionName && currentData) {
                saveSection(activeSectionName, currentData); // 使用原名称和新数据保存
                renderSavedSections();
                nameInputNotification.textContent = `断面 "${activeSectionName}" 已成功覆盖。`;
            }
        });

        // "另存为新断面..." 按钮
        SaveAsNewBtn.addEventListener('click', () => {
           // 转换模态框到新建模式，而不是关闭模态框
            showSaveSectionModal(false);
        });

        // "保存" 按钮
        SaveBtn.addEventListener('click', () => {
            const name = sectionNameInput.value.trim();
            if (!name) {
                nameInputNotification.classList.remove('hidden');
                nameInputNotification.textContent = '断面名称不能为空！';

                return;
            }
            const currentData = sectionDataEl.value.trim();

            saveSection(name, currentData);
            renderSavedSections();
            nameInputNotification.textContent = `断面 "${name}" 已成功保存。`;

            // 更新当前活动断面名称
            activeSectionName = name;
            historyDropdownButton.textContent = name;
            historyDropdownLable.classList.remove('text-gray-500');

            // 关闭模态框
            saveSectionModal.classList.add('hidden');
        });


        // "取消" 按钮
        CancelSaveBtn.addEventListener('click', () => {
            saveSectionModal.classList.add('hidden');
        });


        // 输入框：实时名称校验
        sectionNameInput.addEventListener('input', () => {
            const name = sectionNameInput.value.trim();
            const sections = getSavedSections();

            // 处理特殊情况：输入框为空
            if (name === '') {
                nameInputNotification.textContent = '';
                return;
            }

            // 核心逻辑：检查名称是否重复
            if (sections.some(s => s.name === name)) {
                nameInputNotification.textContent = `名称 "${name}" 已存在，继续将覆盖数据。`;
                OverwriteBtn.classList.remove('hidden');
                return;
            }else{
                nameInputNotification.textContent = '';
                OverwriteBtn.classList.add('hidden');
            }
        });

        // 点击断面模态框外部区域关闭模态框
        saveSectionModal.addEventListener('mousedown', (e) => {
            if (e.target === saveSectionModal) saveSectionModal.classList.add('hidden'); //点击模态框外部区域关闭模态框
            
        });


        /* ========================= 历史记录下拉菜单的交互======================= */

        historyDropdownButton.addEventListener('click', () => historyDropdownPanel.classList.toggle('hidden'));
        window.addEventListener('click', (e) => {
            if (!historyDropdownButton.contains(e.target)) {
                historyDropdownPanel.classList.add('hidden');
            }
        });

        // 计算选项
        useManualWaterLevelsEl.addEventListener('change', () => {
            manualWaterLevelControlsEl.classList.toggle('hidden', !useManualWaterLevelsEl.checked);
        });

        considerFloodplainEl.addEventListener('change', () => {
            // 显示/隐藏控件
            floodplainControlsEl.classList.toggle('hidden', !considerFloodplainEl.checked);
            
            if (considerFloodplainEl.checked) {
                // 启用漫滩计算时的状态管理
                if (parsedSectionPoints.length > 0) {
                    // 只有在第一次启用或岸顶点未设置时才建议初始点
                    if (leftBankPointIndex === -1 || rightBankPointIndex === -1) {
                        suggestInitialBankPoints();
                    }
                }
            } else {
                // 禁用漫滩计算时的状态重置
                leftBankPointIndex = -1;
                rightBankPointIndex = -1;
                hBankfull = -1;
            }
            
            // 清除已有的计算结果
            resultsData = [];
            resultsTableBody.innerHTML = '';
            noResultsMessageEl.classList.remove('hidden');
            document.getElementById('parameterDisplay').classList.add('hidden');
            setStatusMessage('已切换漫滩计算模式，请重新计算。', false);
            
            // 更新界面显示
            updateBankPointInfo();
            drawCrossSection();
        });

        /* ========================= 更新记录模态框的交互======================= */
        showChangelogBtn.addEventListener('click', () => changelogModal.classList.remove('hidden'));
        closeChangelogBtn.addEventListener('click', () => changelogModal.classList.add('hidden'));
        changelogModal.addEventListener('click', (e) => {
            if (e.target === changelogModal) changelogModal.classList.add('hidden'); //点击模态框外部区域关闭模态框
        }); 
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !changelogModal.classList.contains('hidden')) {
                changelogModal.classList.add('hidden');
            }
        });




        /* ========================= 删除断面模态框的交互======================= */
        confirmDeleteBtn.addEventListener('click', () => {
            if (sectionNameToDeleteState) {
                deleteSection(sectionNameToDeleteState);
                renderSavedSections();
                setStatusMessage(`断面 "${sectionNameToDeleteState}" 已删除。`, false);
                sectionNameToDeleteState = null; // 清理状态
            }
            deleteConfirmModal.classList.add('hidden');
        });

        cancelDeleteBtn.addEventListener('click', () => {
            sectionNameToDeleteState = null; // 清理状态
            deleteConfirmModal.classList.add('hidden');
        });

        // 点击删除断面模态框外部区域关闭模态框
        deleteConfirmModal.addEventListener('click', (e) => {
            if (e.target === deleteConfirmModal) {
                sectionNameToDeleteState = null; // 清理状态
                deleteConfirmModal.classList.add('hidden'); //点击模态框外部区域关闭模态框
            }
        });

        // Q-H图表设置
        document.getElementById('updateQHPlotButton').addEventListener('click', updateQHPlot);
        ['showGrid', 'showPoints', 'showDataLabels', 'smoothLine'].forEach(id => {
            document.getElementById(id).addEventListener('change', (e) => {
                qhPlotConfig[id] = e.target.checked;
                updateQHPlot();
            });
        });
        ['x', 'y'].forEach(axis => {
            ['Min', 'Max', 'Step'].forEach(prop => {
                document.getElementById(`${axis}Axis${prop}`).addEventListener('change', (e) => {
                    qhPlotConfig[`${axis}Axis`][prop.toLowerCase()] = e.target.value === '' ? null : parseFloat(e.target.value);
                    updateQHPlot();
                });
            });
        });

        // --------------------------------------------------
        // 7.4 页面初始化调用
        // --------------------------------------------------
        handleUpdatePreview(); // 初始加载时根据默认数据预览断面
        renderSavedSections(); // 加载并显示历史记录

    });
    </script>
</body>
</html>
