<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>断面水位流量关系计算器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style type="text/tailwindcss">
        body { 
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #f0f9ff 0%, #2461e9 100%);
            /* background: linear-gradient(135deg, #2461e9 100% , #f0f9ff 0%); */
        }
        .input-label { 
            @apply block text-sm font-medium text-gray-700 mb-1;
        }
        .input-field { 
            @apply mt-1 block w-full px-3 py-2 bg-white border border-blue-200 rounded-md shadow-sm 
            focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 
            transition duration-150 ease-in-out;
        }
        .button { 
            @apply px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white 
            focus:outline-none focus:ring-2 focus:ring-offset-2 
            transition duration-150 ease-in-out;
        }
        .button-primary { 
            @apply bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 
            focus:ring-blue-500 transform hover:scale-105 transition-transform duration-150
            shadow-lg hover:shadow-xl;
        }
        .button-secondary { 
            @apply bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 
            focus:ring-gray-500 transform hover:scale-105 transition-transform duration-150
            shadow-lg hover:shadow-xl;
        }
        .button-small { 
            @apply px-2 py-1 text-xs;
        }
        #crossSectionCanvas { 
            @apply border-2 border-blue-200 rounded-lg shadow-lg bg-white;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        table {
            @apply min-w-full divide-y divide-blue-200;
        }
        thead {
            @apply bg-blue-50;
        }
        th {
            @apply px-4 py-3 text-left text-xs font-medium text-blue-900 uppercase tracking-wider 
            border-b border-blue-200 bg-blue-50 sticky top-0;
        }
        td {
            @apply px-4 py-4 whitespace-nowrap text-sm text-gray-600 border-b border-blue-100;
        }
        tbody tr:nth-child(even) {
            @apply bg-blue-50;
        }
        tbody tr:hover {
            @apply bg-blue-100 transition-colors duration-150;
        }
        .remark-flood {
            @apply text-red-600 font-medium;
        }
        .remark-main {
            @apply text-green-600 font-medium;
        }
        #noResultsMessage {
            @apply text-center text-gray-500 py-8 bg-blue-50 border-t border-blue-200;
        }
        #statusMessage { 
            @apply mt-4 p-4 rounded-md text-sm font-medium shadow-sm;
        }
        .error { 
            @apply text-red-700;
        }
        .success { 
            @apply text-green-700;
        }
        .card {
            @apply bg-white rounded-lg shadow-lg p-6 border border-blue-100
            hover:shadow-xl transition-shadow duration-300;
        }
        .section-title {
            @apply text-lg font-semibold text-blue-900 mb-4 border-b border-blue-200 pb-2;
        }
        .checkbox-wrapper {
            @apply flex items-center space-x-2 p-2 rounded-md hover:bg-blue-50 transition-colors duration-150;
        }
        input[type="checkbox"] {
            @apply w-4 h-4 text-blue-600 border-blue-300 rounded 
            focus:ring-blue-500 cursor-pointer;
        }
        tbody tr {
            @apply cursor-pointer transition-all duration-150;
        }
        tbody tr.selected {
            @apply bg-blue-200 !important;
        }
        tbody tr:hover:not(.selected) {
            @apply bg-blue-100;
        }
        .parameter-box {
            @apply absolute bg-white/90 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-blue-200 
            text-sm text-gray-700 transition-opacity duration-150;
        }
        .parameter-value {
            @apply font-medium text-blue-600;
        }
        .main-container {
            @apply grid grid-cols-5 gap-6;
            min-height: calc(100vh - 200px);
        }
        .left-section {
            @apply col-span-3 space-y-6;
        }
        .right-section {
            @apply col-span-2 space-y-6;
        }
        .params-section {
            @apply grid grid-cols-2 gap-6;
        }
        .params-box {
            @apply bg-gradient-to-r from-blue-50 to-blue-100 backdrop-blur-sm py-2 px-4 rounded-lg 
            shadow-sm border border-blue-200 flex items-center justify-start space-x-4 text-sm;
        }
        .param-item {
            @apply flex items-center space-x-2 text-blue-800;
        }
        .param-value {
            @apply font-medium text-blue-700;
        }

        .step-number {
            @apply absolute -left-6 -top-6 w-12 h-12 rounded-full bg-blue-600 text-white
            flex items-center justify-center font-bold text-2xl shadow-lg;
        }
        .highlight-section {
            @apply relative bg-gradient-to-br from-blue-50 to-white rounded-xl p-6 shadow-lg
            border-2 border-blue-200;
        }
        .param-inputs {
            @apply space-y-3 mt-4;
        }
        .param-row {
            @apply flex items-center gap-4;
        }
        .param-label {
            @apply w-1/3 text-right font-medium text-blue-800 whitespace-nowrap;
        }
        .param-input {
            @apply w-2/3 px-3 py-2 bg-white border border-blue-200 rounded-md shadow-sm 
            focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 
            transition duration-150 ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-50 p-4 md:p-8">
    <div class="container mx-auto max-w-10xl">
        <h1 class="text-3xl font-bold text-center text-blue-700 mb-8">断面水位流量关系计算器</h1>

        <div class="main-container">
            <div class="left-section">
                <!-- 上部参数区域 -->
                <div class="params-section">
                    <!-- 基本参数 -->
                    <div class="highlight-section h-full flex flex-col min-h-[500px]">
                        <div class="step-number">1</div>
                        <h2 class="section-title">基本参数输入</h2>
                        <div class="space-y-4">
                            <div>
                                <label for="sectionData" class="input-label">断面数据 (平距+高程，由换行符或英文逗号分隔):</label>
                                <textarea id="sectionData" rows="7" class="input-field font-mono text-sm" placeholder="例如:&#10;0 100&#10;10 95&#10;20 92&#10;30 95&#10;40 100">0	88
10	84.813
40	84.813
51.279	84.81
51.657	85.069
53.462	84.694
55.898	82.977
57.978	81.9
60.126	81.23
62.555	80.77
66.298	80.75
70.061	80.95
73.248	81.15
75.808	81.9
77.505	83.583
78.55	83.958
82.581	85.823
84.542	85.927
85.186	85.732
94.934	85.83
96.465	86.721
99.923	86.734
100	88</textarea>
                            </div>
                            <div class="param-inputs">
                                <div class="param-row">
                                    <label for="waterLevelInterval" class="param-label">水位间隔:</label>
                                    <input type="number" id="waterLevelInterval" class="param-input" value="0.5" step="0.1">
                                </div>
                                <div class="param-row">
                                    <label for="manningN_mc" class="param-label">曼宁糙率系数 (n):</label>
                                    <input type="number" id="manningN_mc" class="param-input" value="0.03" step="0.001">
                                </div>
                                <div class="param-row">
                                    <label for="channelSlope" class="param-label">河道坡降 (J):</label>
                                    <input type="number" id="channelSlope" class="param-input" value="0.00177" step="0.0001">
                                </div>
                            </div>
                        </div>
                    </div>

                                        <!-- 计算选项 -->
                    <div class="highlight-section h-full flex flex-col min-h-[500px]">
                        <div class="step-number">2</div>
                        <h2 class="section-title">计算选项设置</h2>
                        
                        <!-- 选项内容区域 -->
                        <div class="flex-grow space-y-4">
                            <div class="input-group">
                                <div class="checkbox-wrapper">
                                    <input id="useManualWaterLevels" type="checkbox">
                                    <label for="useManualWaterLevels" class="text-sm text-gray-700">手动设定计算水位范围</label>
                                </div>
                                <div id="manualWaterLevelControls" class="hidden flex space-x-4 items-end pl-6 mt-2">
                                    <div>
                                        <label for="manualStartWL" class="input-label">起始水位 (m):</label>
                                        <input type="number" id="manualStartWL" class="input-field" step="0.1" placeholder="例如: 80.0">
                                    </div>
                                    <div>
                                        <label for="manualEndWL" class="input-label">终止水位 (m):</label>
                                        <input type="number" id="manualEndWL" class="input-field" step="0.1" placeholder="例如: 88.0">
                                    </div>
                                </div>
                            </div>

                            <div class="input-group">
                                <div class="checkbox-wrapper">
                                    <input id="considerFloodplain" type="checkbox">
                                    <label for="considerFloodplain" class="text-sm text-gray-700">考虑漫滩计算</label>
                                </div>

                                <div id="floodplainControls" class="hidden space-y-3 pl-6 mt-2">
                                    <p class="text-sm text-blue-700 font-medium">调整主槽岸顶 (红点):</p>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <label class="input-label">左岸顶:</label>
                                            <div class="flex space-x-2">
                                                <button id="leftBankPrev" class="button button-secondary button-small">← 左移</button>
                                                <button id="leftBankNext" class="button button-secondary button-small">右移 →</button>
                                            </div>
                                            <p id="leftBankInfo" class="text-xs text-gray-500 mt-1">-</p>
                                        </div>
                                        <div>
                                            <label class="input-label">右岸顶:</label>
                                            <div class="flex space-x-2">
                                                <button id="rightBankPrev" class="button button-secondary button-small">← 左移</button>
                                                <button id="rightBankNext" class="button button-secondary button-small">右移 →</button>
                                            </div>
                                            <p id="rightBankInfo" class="text-xs text-gray-500 mt-1">-</p>
                                        </div>
                                    </div>
                                    <div class="mt-4 pt-4 border-t border-blue-200">
                                        <p class="text-sm text-blue-700 font-medium mb-2">边滩糙率 (可选, 留空则同主槽):</p>
                                        <div class="grid grid-cols-2 gap-4">
                                            <div>
                                                <label for="manningN_lfp" class="input-label">左滩糙率 (n<sub class="text-xs">左</sub>):</label>
                                                <input type="number" id="manningN_lfp" class="param-input text-sm" placeholder="同主槽" step="0.001">
                                            </div>
                                            <div>
                                                <label for="manningN_rfp" class="input-label">右滩糙率 (n<sub class="text-xs">右</sub>):</label>
                                                <input type="number" id="manningN_rfp" class="param-input text-sm" placeholder="同主槽" step="0.001">
                                            </div>
                                        </div>
                                </div>
                                </div>    
                            </div>
                        </div>

                        <!-- 按钮区域 - 始终在底部 -->
                        <div class="mt-auto pt-4 border-t border-blue-200">
                            <div class="flex space-x-4">
                                <button id="updatePreviewButton" class="button button-primary flex-1">
                                    <span class="flex items-center justify-center">
                                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                        </svg>
                                        预览/更新断面
                                    </span>
                                </button>
                                <button id="calculateButton" class="button button-primary bg-green-600 hover:bg-green-700 flex-1">
                                    <span class="flex items-center justify-center">
                                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                                        </svg>
                                        计算
                                    </span>
                                </button>
                            </div>
                        </div>
                    </div>
            </div>

                <!-- 下部绘图区域 -->
                <div class="highlight-section">
                    <div id="parameterDisplay" class="absolute top-12 left-1/2 -translate-x-1/2 hidden params-box z-10">
                        <div class="param-item">
                            <span>过水面积:</span>
                            <span class="param-value" id="paramArea">-</span>
                            <span>m²</span>
                        </div>
                        <div class="param-item">
                            <span>湿周:</span>
                            <span class="param-value" id="paramPerimeter">-</span>
                            <span>m</span>
                        </div>
                        <div class="param-item">
                            <span>流量:</span>
                            <span class="param-value" id="paramFlow">-</span>
                            <span>m³/s</span>
                        </div>
                    </div>
                    <canvas id="crossSectionCanvas" width="800" height="500" class="w-full h-auto"></canvas>
                    <!-- <div id="statusMessage"></div> -->
                </div>
        </div>

            <!-- 右侧结果区域 -->
            <div class="right-section">
                <!-- <div class="highlight-section" style="min-height: calc(100vh - 150px);"> -->
                <div class="highlight-section h-full flex flex-col"> 
                    <div class="step-number">3</div>
                    
                    <!-- 标题和复制按钮 -->
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-baseline gap-1">
                            <h2 class="section-title mb-0">计算结果</h2>
                            <div id="statusMessage"></div>
                        </div>
                        <button id="copyResultsButton" class="button button-secondary">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                </svg>
                                复制结果
                            </span>
                        </button>
                    </div>

                    <!-- 查询功能区域 -->
                    <div class="mt-2">
                        <div class="mb-4 flex items-baseline gap-1">
                            <h3 class="text-lg font-medium text-blue-700 mb-2">水位流量查询：</h3>
                            <p id="queryResultText" class="text-sm text-gray-600 pl-1 hidden"></p>
                        </div>
                        <div class="space-y-4">
                            <!-- 水位查询流量 -->
                            <div class="flex items-center space-x-2">
                                <div class="flex-1">
                                    <input type="number" id="queryWaterLevel" class="input-field py-1 text-sm" step="0.01" placeholder="输入水位...">
                                </div>
                                <button id="queryFlowByLevel" class="button button-primary py-1 px-3 text-sm">
                                    查询流量
                                </button>
                            </div>
                            <!-- 流量查询水位 -->
                            <div class="flex items-center space-x-2">
                                <div class="flex-1">
                                    <input type="number" id="queryFlow" class="input-field py-1 text-sm" step="0.01" placeholder="输入流量...">
                                </div>
                                <button id="queryLevelByFlow" class="button button-primary py-1 px-3 text-sm">
                                    查询水位
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 结果表格 -->
                    <div class="mt-6 overflow-auto max-h-[calc(100vh-500px)]" >
                    <!-- <div class="mt-6 overflow-auto h-full flex flex-col"> -->
                        <table id="resultsTable" class="w-full">
                            <thead class="sticky top-0 bg-gray-50 shadow-sm">
                                <tr>
                                    <th>水位 (m)</th>
                                    <th>过水面积 (m²)</th>
                                    <th>湿周 (m)</th>
                                    <th>水力半径 (m)</th>
                                    <th>流量 (m³/s)</th>
                                    <th>备注</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div id="noResultsMessage" class="hidden text-center text-gray-500 py-8 bg-blue-50 border-t border-blue-200">无计算结果</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 水位流量关系图区域 -->
        <div class="mt-8">
            <h2 class="text-2xl font-bold text-center text-indigo-700 mb-6">水位流量关系图</h2>
            <div class="grid grid-cols-4 gap-6">
                <!-- 左侧绘图区 -->
                <div class="col-span-3">
                    <div class="card">
                        <canvas id="qhCanvas" width="800" height="500" class="w-full h-auto"></canvas>
                    </div>
                </div>
                
                <!-- 右侧配置面板 -->
                <div class="col-span-1">
                    <div class="card space-y-6">
                        <h3 class="text-lg font-semibold text-gray-800">图表设置</h3>
                        
                        <!-- 基本显示设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">基本设置</h4>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showGrid" checked>
                                <label for="showGrid">显示网格</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showPoints" checked>
                                <label for="showPoints">显示数据点</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showDataLabels">
                                <label for="showDataLabels">显示数据标签</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="smoothLine">
                                <label for="smoothLine">平滑曲线</label>
                            </div>
                        </div>

                        <!-- 流量轴（X轴）设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">流量轴设置（横轴）</h4>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="input-label">最小值</label>
                                    <input type="number" id="xAxisMin" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">最大值</label>
                                    <input type="number" id="xAxisMax" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">主刻度间距</label>
                                    <input type="number" id="xAxisStep" class="input-field" placeholder="自动">
                                </div>
                            </div>
                        </div>

                        <!-- 水位轴（Y轴）设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">水位轴设置（纵轴）</h4>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="input-label">最小值</label>
                                    <input type="number" id="yAxisMin" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">最大值</label>
                                    <input type="number" id="yAxisMax" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">主刻度间距</label>
                                    <input type="number" id="yAxisStep" class="input-field" placeholder="自动">
                                </div>
                            </div>
                        </div>

                        <!-- 图表操作按钮 -->
                        <div class="pt-4 border-t border-gray-200">
                            <button id="updateQHPlotButton" class="button button-primary w-full">
                                <span class="flex items-center justify-center">
                                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                    更新图表
                                </span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let parsedSectionPoints = [];
        let leftBankPointIndex = -1;
        let rightBankPointIndex = -1;
        let hBankfull = -1; // This will store min(YL, YR) when floodplain is active
        let resultsData = []; // 将resultsData提升为全局变量
        let intersectionPoints = []; // 存储当前水位的交点信息

        const canvas = document.getElementById('crossSectionCanvas');
        const ctx = canvas.getContext('2d');

        // DOM Elements
        const sectionDataEl = document.getElementById('sectionData');
        const waterLevelIntervalEl = document.getElementById('waterLevelInterval');
        const manningN_mc_El = document.getElementById('manningN_mc');
        const manningN_lfp_El = document.getElementById('manningN_lfp');
        const manningN_rfp_El = document.getElementById('manningN_rfp');
        const channelSlopeEl = document.getElementById('channelSlope');
        const considerFloodplainEl = document.getElementById('considerFloodplain');
        const floodplainControlsEl = document.getElementById('floodplainControls');
        const leftBankInfoEl = document.getElementById('leftBankInfo');
        const rightBankInfoEl = document.getElementById('rightBankInfo');
        // const hBankfullInfoEl = document.getElementById('hBankfullInfo');
        const resultsTableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
        const statusMessageEl = document.getElementById('statusMessage');
        const noResultsMessageEl = document.getElementById('noResultsMessage');

        // New DOM Elements for manual water level control
        const useManualWaterLevelsEl = document.getElementById('useManualWaterLevels');
        const manualWaterLevelControlsEl = document.getElementById('manualWaterLevelControls');
        const manualStartWLEl = document.getElementById('manualStartWL');
        const manualEndWLEl = document.getElementById('manualEndWL');

        // 水位流量关系图相关变量
        const qhCanvas = document.getElementById('qhCanvas');
        const qhCtx = qhCanvas.getContext('2d');
        let qhPlotConfig = {
            showGrid: true,
            showPoints: true,
            showDataLabels: false,
            smoothLine: false,
            xAxis: {
                min: null,
                max: null,
                step: null
            },
            yAxis: {
                min: null,
                max: null,
                step: null
            }
        };

        // 内插查询相关函数
        function linearInterpolate(x, x1, y1, x2, y2) {
            if (x2 === x1) return y1; // 避免除以零
            return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
        }

        function findInterpolationPoints(value, data, valueKey, targetKey) {
            // 确保数据按valueKey排序
            data.sort((a, b) => a[valueKey] - b[valueKey]);
            
            // 如果值小于最小值或大于最大值，返回null
            if (value < data[0][valueKey] || value > data[data.length - 1][valueKey]) {
                return null;
            }
            
            // 找到插值点
            for (let i = 0; i < data.length - 1; i++) {
                if (value === data[i][valueKey]) {
                    // 精确匹配
                    return {
                        exact: true,
                        value: data[i][targetKey]
                    };
                }
                if (value > data[i][valueKey] && value < data[i + 1][valueKey]) {
                    // 需要插值
                    return {
                        exact: false,
                        lower: data[i],
                        upper: data[i + 1]
                    };
                }
            }
            
            // 如果是最后一个值
            if (value === data[data.length - 1][valueKey]) {
                return {
                    exact: true,
                    value: data[data.length - 1][targetKey]
                };
            }
            
            return null;
        }

        function formatNumber(num) {
            return Number(num.toFixed(3));
        }

        function showQueryResult(text) {
            const resultText = document.getElementById('queryResultText');
            resultText.innerHTML = text;
            resultText.classList.remove('hidden');
        }

        function handleWaterLevelQuery() {
            const waterLevel = parseFloat(document.getElementById('queryWaterLevel').value);
            if (isNaN(waterLevel)) {
                showQueryResult('请输入有效的水位值');
                return;
            }

            // 获取所有计算结果数据
            const rows = Array.from(resultsTableBody.rows);
            const data = rows.map(row => ({
                h: parseFloat(row.cells[0].textContent),
                q: parseFloat(row.cells[4].textContent)
            }));

            const result = findInterpolationPoints(waterLevel, data, 'h', 'q');
            
            if (!result) {
                showQueryResult(`水位 ${waterLevel} m 超出计算范围`);
                return;
            }

            if (result.exact) {
                showQueryResult(`水位 ${waterLevel} m 对应的流量为 <span class="text-red-600 font-medium">${formatNumber(result.value)}</span> m³/s`);
            } else {
                const flow = linearInterpolate(
                    waterLevel,
                    result.lower.h,
                    result.lower.q,
                    result.upper.h,
                    result.upper.q
                );
                showQueryResult(`水位 ${waterLevel} m 对应的流量为 <span class="text-red-600 font-medium">${formatNumber(flow)}</span> m³/s（内插值）`);
            }
        }

        function handleFlowQuery() {
            const flow = parseFloat(document.getElementById('queryFlow').value);
            if (isNaN(flow)) {
                showQueryResult('请输入有效的流量值');
                return;
            }

            // 获取所有计算结果数据
            const rows = Array.from(resultsTableBody.rows);
            const data = rows.map(row => ({
                h: parseFloat(row.cells[0].textContent),
                q: parseFloat(row.cells[4].textContent)
            }));

            const result = findInterpolationPoints(flow, data, 'q', 'h');
            
            if (!result) {
                showQueryResult(`流量 ${flow} m³/s 超出计算范围`);
                return;
            }

            if (result.exact) {
                showQueryResult(`流量 ${flow} m³/s 对应的水位为 <span class="text-red-600 font-medium">${formatNumber(result.value)}</span> m`);
            } else {
                const waterLevel = linearInterpolate(
                    flow,
                    result.lower.q,
                    result.lower.h,
                    result.upper.q,
                    result.upper.h
                );
                showQueryResult(`流量 ${flow} m³/s 对应的水位为 <span class="text-red-600 font-medium">${formatNumber(waterLevel)}</span> m（内插值）`);
            }
        }

        // 绑定查询按钮事件
        document.getElementById('queryFlowByLevel').addEventListener('click', handleWaterLevelQuery);
        document.getElementById('queryLevelByFlow').addEventListener('click', handleFlowQuery);

        // 为查询输入框添加回车键事件
        document.getElementById('queryWaterLevel').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleWaterLevelQuery();
        });
        document.getElementById('queryFlow').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleFlowQuery();
        });

        // Event Listeners
        document.getElementById('updatePreviewButton').addEventListener('click', handleUpdatePreview);
        document.getElementById('calculateButton').addEventListener('click', handleCalculate);
        document.getElementById('copyResultsButton').addEventListener('click', copyResultsToClipboard);
        
        considerFloodplainEl.addEventListener('change', () => {
            // 显示/隐藏控件
            floodplainControlsEl.classList.toggle('hidden', !considerFloodplainEl.checked);
            
            if (considerFloodplainEl.checked) {
                // 启用漫滩计算时的状态管理
                if (parsedSectionPoints.length > 0) {
                    // 只有在第一次启用或岸顶点未设置时才建议初始点
                    if (leftBankPointIndex === -1 || rightBankPointIndex === -1) {
                        suggestInitialBankPoints();
                    }
                }
            } else {
                // 禁用漫滩计算时的状态重置
                leftBankPointIndex = -1;
                rightBankPointIndex = -1;
                hBankfull = -1;
            }
            
            // 清除已有的计算结果
            resultsData = [];
            resultsTableBody.innerHTML = '';
            noResultsMessageEl.classList.remove('hidden');
            document.getElementById('parameterDisplay').classList.add('hidden');
            setStatusMessage('已切换漫滩计算模式，请重新计算。', false);
            
            // 更新界面显示
            updateBankPointInfo();
            drawCrossSection();
        });

        // Event listener for the new manual water level checkbox
        useManualWaterLevelsEl.addEventListener('change', () => {
            manualWaterLevelControlsEl.classList.toggle('hidden', !useManualWaterLevelsEl.checked);
        });

        document.getElementById('leftBankPrev').addEventListener('click', () => adjustBankPoint('left', -1));
        document.getElementById('leftBankNext').addEventListener('click', () => adjustBankPoint('left', 1));
        document.getElementById('rightBankPrev').addEventListener('click', () => adjustBankPoint('right', -1));
        document.getElementById('rightBankNext').addEventListener('click', () => adjustBankPoint('right', 1));

        // 绑定配置面板事件
        document.getElementById('showGrid').addEventListener('change', e => {
            qhPlotConfig.showGrid = e.target.checked;
            updateQHPlot();
        });
        document.getElementById('showPoints').addEventListener('change', e => {
            qhPlotConfig.showPoints = e.target.checked;
            updateQHPlot();
        });
        document.getElementById('showDataLabels').addEventListener('change', e => {
            qhPlotConfig.showDataLabels = e.target.checked;
            updateQHPlot();
        });
        document.getElementById('smoothLine').addEventListener('change', e => {
            qhPlotConfig.smoothLine = e.target.checked;
            updateQHPlot();
        });
        document.getElementById('updateQHPlotButton').addEventListener('click', updateQHPlot);

        ['x', 'y'].forEach(axis => {
            ['Min', 'Max', 'Step'].forEach(prop => {
                const input = document.getElementById(`${axis}Axis${prop}`);
                input.addEventListener('change', e => {
                    const value = e.target.value === '' ? null : parseFloat(e.target.value);
                    qhPlotConfig[`${axis}Axis`][prop.toLowerCase()] = value;
                    updateQHPlot();
                });
            });
        });

        // --- Core Logic ---

        function parseSectionData() {
            const data = sectionDataEl.value.trim();
            if (!data) {
                setStatusMessage('断面数据不能为空。', true);
                parsedSectionPoints = []; 
                return false;
            }
            const lines = data.split('\n');
            parsedSectionPoints = [];
            for (let i = 0; i < lines.length; i++) {
                const parts = lines[i].trim().split(/[\s,]+/);
                if (parts.length === 2) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    if (!isNaN(x) && !isNaN(y)) {
                        parsedSectionPoints.push({ x, y, originalIndex: i });
                    } else {
                        setStatusMessage(`数据格式错误在行 ${i+1}: "${lines[i]}"`, true);
                        return false;
                    }
                } else if (lines[i].trim() !== "") { 
                     setStatusMessage(`数据格式错误在行 ${i+1}: "${lines[i]}" (应为 X Y)`, true);
                    return false;
                }
            }

            if (parsedSectionPoints.length < 2) {
                setStatusMessage('断面数据至少需要两个点。', true);
                return false;
            }

            parsedSectionPoints.sort((a, b) => a.x - b.x);
            setStatusMessage('断面数据解析成功。', false);
            return true;
        }

        function suggestInitialBankPoints() {
            if (parsedSectionPoints.length < 3) { 
                leftBankPointIndex = 0;
                rightBankPointIndex = parsedSectionPoints.length > 1 ? 1 : 0;
            } else {
                let lowestY = Infinity;
                let lowestIdx = -1;
                parsedSectionPoints.forEach((p, idx) => {
                    if (p.y < lowestY) {
                        lowestY = p.y;
                        lowestIdx = idx;
                    }
                });

                if (lowestIdx !== -1) {
                    const quarterLength = Math.max(1, Math.floor(parsedSectionPoints.length / 5)); 
                    leftBankPointIndex = Math.max(0, lowestIdx - quarterLength);
                    rightBankPointIndex = Math.min(parsedSectionPoints.length - 1, lowestIdx + quarterLength);

                    if (leftBankPointIndex >= rightBankPointIndex) { 
                       if (lowestIdx > 0) {
                           leftBankPointIndex = lowestIdx -1;
                           if (lowestIdx < parsedSectionPoints.length -1) {
                               rightBankPointIndex = lowestIdx + 1;
                           } else {
                               rightBankPointIndex = lowestIdx; 
                               if (leftBankPointIndex === rightBankPointIndex && leftBankPointIndex > 0) leftBankPointIndex--; 
                           }
                       } else if (lowestIdx < parsedSectionPoints.length -1) { 
                           leftBankPointIndex = lowestIdx;
                           rightBankPointIndex = lowestIdx + 1;
                       } else { 
                           leftBankPointIndex = 0;
                           rightBankPointIndex = parsedSectionPoints.length > 1 ? 1: 0;
                       }
                    }
                } else { 
                    leftBankPointIndex = Math.floor(parsedSectionPoints.length / 3);
                    rightBankPointIndex = Math.floor(2 * parsedSectionPoints.length / 3);
                }
            }
             if (leftBankPointIndex === rightBankPointIndex && parsedSectionPoints.length > 1) {
                if (rightBankPointIndex < parsedSectionPoints.length - 1) rightBankPointIndex++;
                else if (leftBankPointIndex > 0) leftBankPointIndex--;
            }
            updateBankPointInfo();
        }
        
        function adjustBankPoint(side, direction) {
            // 基本验证
            if (!considerFloodplainEl.checked || parsedSectionPoints.length === 0) return;

            let stateChanged = false;

            // 状态更新逻辑 - 仅更新索引
            if (side === 'left') {
                const newIndex = leftBankPointIndex + direction;
                const maxAllowed = rightBankPointIndex === -1 ? parsedSectionPoints.length - 1 : rightBankPointIndex;
                if (newIndex >= 0 && newIndex < maxAllowed) {
                    leftBankPointIndex = newIndex;
                    stateChanged = true;
                }
            } else if (side === 'right') {
                const newIndex = rightBankPointIndex + direction;
                const minAllowed = leftBankPointIndex === -1 ? 0 : leftBankPointIndex;
                if (newIndex < parsedSectionPoints.length && newIndex > minAllowed) {
                    rightBankPointIndex = newIndex;
                    stateChanged = true;
                }
            }

            // 只有在状态确实发生改变时才更新界面
            if (stateChanged) {
                // 仅更新坐标显示
                updateBankPointInfo();
                // 重绘断面图（不含临界岸顶高程线）
                drawCrossSection();
            }
        }

        function updateBankPointInfo() {
            // 获取左右岸顶点信息
            const ptL = (leftBankPointIndex !== -1 && parsedSectionPoints[leftBankPointIndex]) ? parsedSectionPoints[leftBankPointIndex] : null;
            const ptR = (rightBankPointIndex !== -1 && parsedSectionPoints[rightBankPointIndex]) ? parsedSectionPoints[rightBankPointIndex] : null;

            // 更新左岸顶坐标显示
            if (ptL) {
                leftBankInfoEl.textContent = `X:${ptL.x.toFixed(2)}, Y:${ptL.y.toFixed(2)} (点 ${leftBankPointIndex})`;
            } else {
                leftBankInfoEl.textContent = '-';
            }

            // 更新右岸顶坐标显示
            if (ptR) {
                rightBankInfoEl.textContent = `X:${ptR.x.toFixed(2)}, Y:${ptR.y.toFixed(2)} (点 ${rightBankPointIndex})`;
            } else {
                rightBankInfoEl.textContent = '-';
            }

            // // 更新临界岸顶高程显示（不计算，仅显示当前值）
            // if (considerFloodplainEl.checked && hBankfull !== -1) {
            //     hBankfullInfoEl.textContent = `临界岸顶高程: ${hBankfull.toFixed(2)} m`;
            // } else {
            //     hBankfullInfoEl.textContent = '临界岸顶高程: -';
            // }
        }

        function calculateNiceNumber(range, round) {
            const exponent = Math.floor(Math.log10(range));
            const fraction = range / Math.pow(10, exponent);
            let niceFraction;

            if (round) {
                if (fraction < 1.5) niceFraction = 1;
                else if (fraction < 3) niceFraction = 2;
                else if (fraction < 7) niceFraction = 5;
                else niceFraction = 10;
            } else {
                if (fraction <= 1) niceFraction = 1;
                else if (fraction <= 2) niceFraction = 2;
                else if (fraction <= 5) niceFraction = 5;
                else niceFraction = 10;
            }

            return niceFraction * Math.pow(10, exponent);
        }

        function calculateAxisParameters(min, max) {
            const range = calculateNiceNumber(max - min, false);
            const tickSpacing = calculateNiceNumber(range / (8 - 1), true);
            const niceMin = Math.floor(min / tickSpacing) * tickSpacing;
            const niceMax = Math.ceil(max / tickSpacing) * tickSpacing;

            return {
                min: niceMin,
                max: niceMax,
                tickSpacing: tickSpacing
            };
        }

        function drawCrossSection(currentWaterLevel = null, selectedData = null) {
            console.log("绘图函数 drawCrossSection 已被调用！");
            // 1. 基本验证和画布准备
            if (parsedSectionPoints.length < 2) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            // 设置canvas的DPI以提高清晰度
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. 计算绘图区域尺寸
            const padding = 60;
            const viewWidth = canvas.width / dpr - 2 * padding;
            const viewHeight = canvas.height / dpr - 2 * padding;

            // 3. 计算数据范围
            // X轴范围（断面距离）
            const minX_data = parsedSectionPoints[0].x;
            const maxX_data = parsedSectionPoints[parsedSectionPoints.length - 1].x;

            // Y轴范围（高程）
            let minY_data = Infinity, maxY_data = -Infinity;
            parsedSectionPoints.forEach(p => {
                minY_data = Math.min(minY_data, p.y);
                maxY_data = Math.max(maxY_data, p.y);
            });

            // 4. 确定绘图范围
            let plotMinY = minY_data;
            let plotMaxY = maxY_data;

            // 考虑水位线的影响
            if (currentWaterLevel !== null && !isNaN(currentWaterLevel)) {
                plotMaxY = Math.max(plotMaxY, currentWaterLevel);
                plotMinY = Math.min(plotMinY, currentWaterLevel);
            }

            // 考虑漫滩计算的影响
            if (considerFloodplainEl.checked) {
                console.log(`准备绘制红点，左岸索引: ${leftBankPointIndex}, 右岸索引: ${rightBankPointIndex}`);
                // 检查岸顶点是否有效
                const leftBankPoint = leftBankPointIndex !== -1 ? parsedSectionPoints[leftBankPointIndex] : null;
                const rightBankPoint = rightBankPointIndex !== -1 ? parsedSectionPoints[rightBankPointIndex] : null;

                if (leftBankPoint) {
                    plotMaxY = Math.max(plotMaxY, leftBankPoint.y);
                }
                if (rightBankPoint) {
                    plotMaxY = Math.max(plotMaxY, rightBankPoint.y);
                }
                if (hBankfull !== -1) {
                    plotMaxY = Math.max(plotMaxY, hBankfull);
                }
            }

            // 5. 添加缓冲区并处理边界情况
            const plotRange = plotMaxY - plotMinY;
            const yBuffer = Math.max(plotRange * 0.1, 0.1); // 确保至少有0.1的缓冲
            plotMinY = Math.min(plotMinY - yBuffer, minY_data - yBuffer);
            plotMaxY = Math.max(plotMaxY + yBuffer, maxY_data + yBuffer);

            // 处理Y轴范围相等的特殊情况
            if (Math.abs(plotMaxY - plotMinY) < 0.0001) {
                plotMinY -= 1;
                plotMaxY += 1;
            }

            // 6. 计算坐标轴的合理范围和间隔
            const xAxisParams = calculateAxisParameters(minX_data, maxX_data);
            const yAxisParams = calculateAxisParameters(plotMinY, plotMaxY);

            // 使用计算出的合理范围
            const plotMinX = xAxisParams.min;
            const plotMaxX = xAxisParams.max;
            plotMinY = yAxisParams.min;
            plotMaxY = yAxisParams.max;

            // 7. 计算坐标转换函数
            // 确保分母不为零
            const xRange = Math.max(plotMaxX - plotMinX, 0.0001);
            const yRange = Math.max(plotMaxY - plotMinY, 0.0001);
            
            const scaleX = viewWidth / xRange;
            const scaleY = viewHeight / yRange;

            const toCanvasX = (worldX) => padding + (worldX - plotMinX) * scaleX;
            const toCanvasY = (worldY) => canvas.height / dpr - padding - (worldY - plotMinY) * scaleY;

            // 绘制坐标轴
            ctx.beginPath();
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            
            // 绘制网格线
            const gridColor = '#f3f4f6';
            const xTicks = Math.round((maxX_data - minX_data) / xAxisParams.tickSpacing);
            const yTicks = Math.round((plotMaxY - plotMinY) / yAxisParams.tickSpacing);
            
            ctx.beginPath();
            for (let i = 0; i <= xTicks; i++) {
                const x = padding + (viewWidth * i) / xTicks;
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height / dpr - padding);
            }
            for (let i = 0; i <= yTicks; i++) {
                const y = padding + (viewHeight * i) / yTicks;
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width / dpr - padding, y);
            }
            ctx.strokeStyle = gridColor;
            ctx.stroke();

            // 绘制坐标轴
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height / dpr - padding);
            ctx.lineTo(canvas.width / dpr - padding, canvas.height / dpr - padding);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height / dpr - padding);
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // 绘制标签
            ctx.fillStyle = '#4b5563';
            ctx.font = '12px Inter';
            
            // X轴标签
            for (let i = 0; i <= xTicks; i++) {
                const val = minX_data + i * xAxisParams.tickSpacing;
                const xPos = toCanvasX(val);
                ctx.textAlign = "center";
                ctx.fillText(val.toFixed(0), xPos, canvas.height / dpr - padding + 20);
                
                ctx.beginPath();
                ctx.moveTo(xPos, canvas.height / dpr - padding);
                ctx.lineTo(xPos, canvas.height / dpr - padding + 5);
                ctx.strokeStyle = '#9ca3af';
                ctx.stroke();
            }
            
            // Y轴标签
            for (let i = 0; i <= yTicks; i++) {
                const val = plotMinY + i * yAxisParams.tickSpacing;
                const yPos = toCanvasY(val);
                ctx.textAlign = "right";
                ctx.fillText(val.toFixed(2), padding - 8, yPos + 4);
                
                 ctx.beginPath();
                ctx.moveTo(padding - 5, yPos);
                ctx.lineTo(padding, yPos);
                ctx.strokeStyle = '#9ca3af';
                ctx.stroke();
            }

            // 添加轴标题
            ctx.save();
            ctx.translate(padding - 40, canvas.height / dpr / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.fillText("高程 (m)", 0, 0);
            ctx.restore();
            
            ctx.textAlign = "center";
            ctx.fillText("距离 (m)", canvas.width / dpr / 2, canvas.height / dpr - padding + 35);

            // 绘制断面线
            ctx.beginPath();
            ctx.moveTo(toCanvasX(parsedSectionPoints[0].x), toCanvasY(parsedSectionPoints[0].y));
            parsedSectionPoints.forEach(p => {
                ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
            });
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 填充断面下方区域
            ctx.beginPath();
            ctx.moveTo(toCanvasX(parsedSectionPoints[0].x), toCanvasY(parsedSectionPoints[0].y));
            parsedSectionPoints.forEach(p => {
                ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
            });
            ctx.lineTo(toCanvasX(parsedSectionPoints[parsedSectionPoints.length - 1].x), toCanvasY(plotMinY));
            ctx.lineTo(toCanvasX(parsedSectionPoints[0].x), toCanvasY(plotMinY));
            ctx.closePath();
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.fill();

            // 绘制断面点
            parsedSectionPoints.forEach((p, index) => {
                const x = toCanvasX(p.x);
                const y = toCanvasY(p.y);
                
                // 绘制点的外圈（白色边框）
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制点的内圈
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fillStyle = '#3b82f6';
                ctx.fill();

                // 可选：每隔几个点显示一个序号
                if (parsedSectionPoints.length <= 30 || index % Math.ceil(parsedSectionPoints.length / 15) === 0) {
                    ctx.fillStyle = '#6B7280';
                    ctx.font = '10px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(`${index + 1}`, x, y - 8);
                }
            });

            // 绘制岸顶点和水位线
            if (considerFloodplainEl.checked) {
                const ptL = (leftBankPointIndex !== -1 && parsedSectionPoints[leftBankPointIndex]) ? parsedSectionPoints[leftBankPointIndex] : null;
                const ptR = (rightBankPointIndex !== -1 && parsedSectionPoints[rightBankPointIndex]) ? parsedSectionPoints[rightBankPointIndex] : null;

                if (ptL) {
                    ctx.beginPath();
                    ctx.arc(toCanvasX(ptL.x), toCanvasY(ptL.y), 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#ef4444';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                if (ptR) {
                    ctx.beginPath();
                    ctx.arc(toCanvasX(ptR.x), toCanvasY(ptR.y), 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#ef4444';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                if (hBankfull !== -1 && hBankfull >= plotMinY && hBankfull <= plotMaxY) { 
                    ctx.beginPath();
                    ctx.moveTo(padding, toCanvasY(hBankfull));
                    ctx.lineTo(canvas.width / dpr - padding, toCanvasY(hBankfull));
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.7)';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // 添加标签背景
                    const label = `岸顶高程: ${hBankfull.toFixed(2)}`;
                    const labelWidth = ctx.measureText(label).width + 10;
                    const labelX = canvas.width / dpr - padding - labelWidth - 10;
                    const labelY = toCanvasY(hBankfull) - 20;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(labelX - 5, labelY - 12, labelWidth + 10, 24);
                    
                    ctx.fillStyle = '#ef4444';
                    ctx.textAlign = "left";
                    ctx.fillText(label, labelX, labelY + 4);
                }
            }

            // 绘制水位线和填充区域
            if (currentWaterLevel !== null && currentWaterLevel >= plotMinY && currentWaterLevel <= plotMaxY) {
                ctx.beginPath();
                ctx.moveTo(padding, toCanvasY(currentWaterLevel));
                ctx.lineTo(canvas.width / dpr - padding, toCanvasY(currentWaterLevel));
                ctx.strokeStyle = '#06b6d4';
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);

                // 添加水位标签背景
                const label = `水位: ${currentWaterLevel.toFixed(2)}m`;
                const labelWidth = ctx.measureText(label).width + 10;
                const labelX = padding + 10;
                const labelY = toCanvasY(currentWaterLevel) - 20;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(labelX - 5, labelY - 12, labelWidth + 10, 24);

                ctx.fillStyle = '#0891b2';
                ctx.textAlign = "left";
                ctx.fillText(label, labelX, labelY + 4);

                // 使用预先计算的交点信息填充水域
                if (selectedData && selectedData.intersectionPoints && selectedData.intersectionPoints.length >= 2) {
                    const intersectionPoints = selectedData.intersectionPoints;
                    
                    // 开始绘制填充区域
                    ctx.beginPath();
                    
                    // 从第一个交点开始
                    ctx.moveTo(toCanvasX(intersectionPoints[0].x), toCanvasY(intersectionPoints[0].y));
                    
                    // 找到位于第一个和最后一个交点之间的所有断面点
                    const firstX = intersectionPoints[0].x;
                    const lastX = intersectionPoints[intersectionPoints.length - 1].x;
                    
                    // 绘制第一个交点到最后一个交点之间的河床轮廓
                    let foundStart = false;
                    for (let i = 0; i < parsedSectionPoints.length; i++) {
                        const point = parsedSectionPoints[i];
                        if (point.x >= firstX && point.x <= lastX) {
                            if (!foundStart) {
                                foundStart = true;
                            }
                            ctx.lineTo(toCanvasX(point.x), toCanvasY(point.y));
                        } else if (foundStart) {
                            break;
                        }
                    }
                    
                    // 连接到最后一个交点
                    ctx.lineTo(toCanvasX(lastX), toCanvasY(currentWaterLevel));
                    
                    // 闭合路径
                    ctx.lineTo(toCanvasX(firstX), toCanvasY(currentWaterLevel));
                    ctx.closePath();
                    
                    // 填充
                    ctx.fillStyle = 'rgba(6, 182, 212, 0.2)';
                    ctx.fill();
                }
            }

            // 如果有选中的数据，更新参数显示
            const parameterDisplay = document.getElementById('parameterDisplay');
            if (selectedData) {
                document.getElementById('paramArea').textContent = selectedData.a;
                document.getElementById('paramPerimeter').textContent = selectedData.p;
                document.getElementById('paramFlow').textContent = selectedData.q;
                parameterDisplay.classList.remove('hidden');
            } else {
                parameterDisplay.classList.add('hidden');
            }
        }

        function calculateGeometricProperties(segmentPoints, waterLevel) {
            let area = 0;
            let bedPerimeter = 0;
            let intersectionPoints = [];
            
            if (!segmentPoints || segmentPoints.length < 2) {
                return { area: 0, bedPerimeter: 0, intersectionPoints: [] };
            }

            let firstIntersectionFound = false;
            let lastIntersectionFound = false;

            for (let i = 0; i < segmentPoints.length - 1; i++) {
                const p1 = segmentPoints[i];
                const p2 = segmentPoints[i + 1];

                const x1 = p1.x, y1 = p1.y;
                const x2 = p2.x, y2 = p2.y;
                const dx = x2 - x1;

                if (dx < 0) { console.warn("Segment points not sorted by X", p1, p2); continue; }
                if (dx === 0 && y1 === y2) continue; 

                const h1 = waterLevel - y1; 
                const h2 = waterLevel - y2; 

                if (y1 >= waterLevel && y2 >= waterLevel) { 
                    continue; 
                }

                if (y1 < waterLevel && y2 < waterLevel) { 
                    area += dx * (h1 + h2) / 2.0; 
                    bedPerimeter += Math.sqrt(dx * dx + (y2 - y1) * (y2 - y1));
                } else { 
                    if (y1 === y2) { 
                        if (y1 < waterLevel) { 
                             area += dx * h1; 
                        }
                        continue;
                    }
                    
                    const ix = x1 + dx * (waterLevel - y1) / (y2 - y1);
                    const intersectionPoint = { x: ix, y: waterLevel };

                    if (!firstIntersectionFound) {
                        intersectionPoints.push(intersectionPoint);
                        firstIntersectionFound = true;
                    } else if (!lastIntersectionFound) {
                        intersectionPoints.push(intersectionPoint);
                        lastIntersectionFound = true;
                    }

                    if (y1 < waterLevel) { 
                        area += (ix - x1) * h1 / 2.0; 
                        bedPerimeter += Math.sqrt(Math.pow(ix - x1, 2) + Math.pow(waterLevel - y1, 2));
                    } else { 
                        area += (x2 - ix) * h2 / 2.0; 
                        bedPerimeter += Math.sqrt(Math.pow(x2 - ix, 2) + Math.pow(waterLevel - y2, 2));
                    }
                }
            }

            // 如果只找到一个交点，说明水位线与断面只有一个交点（比如在端点）
            // 此时将该点作为两个交点
            if (intersectionPoints.length === 1) {
                intersectionPoints.push({ ...intersectionPoints[0] });
            }

            return {
                area: Math.max(0, area),
                bedPerimeter: Math.max(0, bedPerimeter),
                intersectionPoints: intersectionPoints
            };
        }

        function handleUpdatePreview() {
            // 清除画布，准备重新绘制
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 解析断面数据
            if (!parseSectionData()) {
                setStatusMessage('断面数据解析失败，请检查输入格式。', true);
                return;
            }

            // 验证数据有效性
            if (parsedSectionPoints.length === 0) {
                setStatusMessage('没有有效的断面数据。', true);
                return;
            }

            // 重新绘制断面图
            drawCrossSection();
            setStatusMessage('断面图已更新。', false);
        }

        function handleCalculate() {
            if (!parseSectionData()) return;

            // 1. 计算临界岸顶高程（如果启用了漫滩计算）
            if (considerFloodplainEl.checked && leftBankPointIndex !== -1 && rightBankPointIndex !== -1) {
                const leftBankPoint = parsedSectionPoints[leftBankPointIndex];
                const rightBankPoint = parsedSectionPoints[rightBankPointIndex];
                if (leftBankPoint && rightBankPoint) {
                    hBankfull = Math.min(leftBankPoint.y, rightBankPoint.y);
                    updateBankPointInfo(); // 更新显示
                }
            } else {
                hBankfull = -1;
            }

            // 2. 获取计算参数
            const waterLevelStep = parseFloat(waterLevelIntervalEl.value);
            const n_mc_val = parseFloat(manningN_mc_El.value);
            const i_val = parseFloat(channelSlopeEl.value);
            const useManualLevels = useManualWaterLevelsEl.checked;

            if (isNaN(waterLevelStep) || waterLevelStep <= 0) {
                setStatusMessage('无效的水位间隔。', true); return;
            }
            if (isNaN(n_mc_val) || n_mc_val <= 0) {
                setStatusMessage('无效的曼宁糙率系数 (必须 > 0)。', true); return;
            }
            if (isNaN(i_val) || i_val <= 0) { 
                setStatusMessage('无效的河道坡降 (必须 > 0)。', true); return;
            }
            
            // 重置结果
            resultsData = [];
            resultsTableBody.innerHTML = '';
            let lastPlottedWL = null;

            // 计算水位范围
            let minY_data = Infinity;
            let maxY_data_overall = -Infinity;
                parsedSectionPoints.forEach(p => {
                    minY_data = Math.min(minY_data, p.y);
                    maxY_data_overall = Math.max(maxY_data_overall, p.y);
                });

            if (parsedSectionPoints.length === 0) {
                setStatusMessage('断面数据为空，无法计算。', true);
                noResultsMessageEl.classList.remove('hidden');
                return;
            }

            let startWL, endWL; 

            if (useManualLevels) {
                const manualStart = parseFloat(manualStartWLEl.value);
                const manualEnd = parseFloat(manualEndWLEl.value);

                if (isNaN(manualStart) || isNaN(manualEnd)) {
                    setStatusMessage('手动输入的起始或终止水位无效。请检查输入。', true);
                    return;
                }
                if (manualStart >= manualEnd) {
                    setStatusMessage('手动起始水位必须小于终止水位。', true);
                    return;
                }
                startWL = manualStart;
                endWL = manualEnd;
                setStatusMessage('使用手动设定的水位范围进行计算。', false);
            } else {
                startWL = Math.ceil(minY_data / waterLevelStep) * waterLevelStep;
                if (startWL <= minY_data) startWL += waterLevelStep; 

                let endWL_max_coord = Math.max(parsedSectionPoints[0].y, parsedSectionPoints[parsedSectionPoints.length-1].y);
                endWL = Math.min(maxY_data_overall + waterLevelStep, endWL_max_coord + 10 * waterLevelStep); 

                if (considerFloodplainEl.checked && leftBankPointIndex !== -1 && rightBankPointIndex !== -1 &&
                    parsedSectionPoints[leftBankPointIndex] && parsedSectionPoints[rightBankPointIndex]) {
                    const YL_for_endWL = parsedSectionPoints[leftBankPointIndex].y;
                    const YR_for_endWL = parsedSectionPoints[rightBankPointIndex].y;
                    endWL = Math.max(endWL, YL_for_endWL + 5 * waterLevelStep, YR_for_endWL + 5 * waterLevelStep);
                    endWL = Math.min(endWL, maxY_data_overall + 5 * waterLevelStep); 
                }

                if (endWL <= startWL) {
                    endWL = startWL + waterLevelStep * 5;
                }
            }

            if (startWL >= endWL + waterLevelStep/2) { 
                setStatusMessage('无法确定有效的计算水位范围 (起始水位 >= 终止水位)。请检查断面数据、岸顶定义、水位间隔或手动输入。', true);
                noResultsMessageEl.classList.remove('hidden');
                return;
            }

            // 开始计算
            for (let currentWL_iter = startWL; currentWL_iter <= endWL; currentWL_iter += waterLevelStep) {
                const currentWL = parseFloat(currentWL_iter.toFixed(5)); 
                let A_final = 0, P_final = 0, R_final = 0, Q_final = 0;
                let remark = "-";
                let intersectionPoints = [];

                const floodplainActiveAndDefined = considerFloodplainEl.checked && 
                                                 leftBankPointIndex !== -1 && 
                                                 rightBankPointIndex !== -1 &&
                                                 parsedSectionPoints[leftBankPointIndex] && 
                                                 parsedSectionPoints[rightBankPointIndex];

                if (!floodplainActiveAndDefined) {
                    const geom = calculateGeometricProperties(parsedSectionPoints, currentWL);
                    A_final = geom.area;
                    P_final = geom.bedPerimeter; 
                    intersectionPoints = geom.intersectionPoints;
                    
                    if (A_final > 0 && P_final > 0) {
                        R_final = A_final / P_final;
                        if (n_mc_val > 0 && i_val > 0) {
                           Q_final = (1 / n_mc_val) * A_final * Math.pow(R_final, 2/3) * Math.pow(i_val, 1/2);
                        }
                    }
                } else {
                    const YL_val = parsedSectionPoints[leftBankPointIndex].y;
                    const YR_val = parsedSectionPoints[rightBankPointIndex].y;

                    const n_mc_val = parseFloat(manningN_mc_El.value);//主槽糙率

                    let n_lfp_val = parseFloat(manningN_lfp_El.value);//左滩糙率
                    if (isNaN(n_lfp_val) || n_lfp_val <= 0) {//尝试获取左滩糙率
                        n_lfp_val = n_mc_val;// 若左滩糙率无效，则使用主槽糙率
                    }
                    let n_rfp_val = parseFloat(manningN_rfp_El.value);//右滩糙率
                    if (isNaN(n_rfp_val) || n_rfp_val <= 0) {//尝试获取右滩糙率
                        n_rfp_val = n_mc_val;// 若右滩糙率无效，则使用主槽糙率
                    }

                    if (currentWL > hBankfull) { 
                        remark = "漫滩";
                    } else {
                        remark = "主槽"; 
                    }

                    const points_mc = parsedSectionPoints.slice(leftBankPointIndex, rightBankPointIndex + 1);
                    const points_lfp = parsedSectionPoints.slice(0, leftBankPointIndex + 1);
                    const points_rfp = parsedSectionPoints.slice(rightBankPointIndex);

                    const geom_mc = calculateGeometricProperties(points_mc, currentWL);
                    let A_mc = geom_mc.area;
                    let P_mc_bed = geom_mc.bedPerimeter;
                    let intersectionPoints_mc = geom_mc.intersectionPoints;

                    let P_mc = P_mc_bed + Math.max(0, currentWL - YL_val) + Math.max(0, currentWL - YR_val);
                    let R_mc = (A_mc > 0 && P_mc > 0) ? A_mc / P_mc : 0;
                    let Q_mc = (A_mc > 0 && R_mc > 0 && n_mc_val > 0 && i_val > 0) ? 
                               (1/n_mc_val) * A_mc * Math.pow(R_mc, 2/3) * Math.pow(i_val, 1/2) : 0;
                    if (A_mc <= 0) Q_mc = 0;

                    let A_lfp = 0, Q_lfp = 0;
                    let intersectionPoints_lfp = [];
                    if (currentWL > YL_val) { 
                        const geom_lfp = calculateGeometricProperties(points_lfp, currentWL);
                        A_lfp = geom_lfp.area;
                        intersectionPoints_lfp = geom_lfp.intersectionPoints;
                        if (A_lfp > 0) {
                            let P_lfp_bed_component = geom_lfp.bedPerimeter;
                            let P_lfp_component = P_lfp_bed_component + Math.max(0, currentWL - YL_val);
                            let R_lfp_component = (P_lfp_component > 0) ? A_lfp / P_lfp_component : 0;
                            Q_lfp = (A_lfp > 0 && R_lfp_component > 0 && n_lfp_val > 0 && i_val > 0) ? 
                                    (1/n_lfp_val) * A_lfp * Math.pow(R_lfp_component, 2/3) * Math.pow(i_val, 1/2) : 0;
                        }
                    }
                    if (A_lfp <= 0) Q_lfp = 0; 

                    let A_rfp = 0, Q_rfp = 0;
                    let intersectionPoints_rfp = [];
                    if (currentWL > YR_val) { 
                        const geom_rfp = calculateGeometricProperties(points_rfp, currentWL);
                        A_rfp = geom_rfp.area;
                        intersectionPoints_rfp = geom_rfp.intersectionPoints;
                        if (A_rfp > 0) {
                            let P_rfp_bed_component = geom_rfp.bedPerimeter;
                            let P_rfp_component = P_rfp_bed_component + Math.max(0, currentWL - YR_val);
                            let R_rfp_component = (P_rfp_component > 0) ? A_rfp / P_rfp_component : 0;
                            Q_rfp = (A_rfp > 0 && R_rfp_component > 0 && n_rfp_val > 0 && i_val > 0) ? 
                                    (1/n_rfp_val) * A_rfp * Math.pow(R_rfp_component, 2/3) * Math.pow(i_val, 1/2) : 0;
                        }
                    }
                    if (A_rfp <= 0) Q_rfp = 0; 

                    Q_final = Q_mc + Q_lfp + Q_rfp;
                    A_final = A_mc + A_lfp + A_rfp;

                    // 合并所有交点
                    intersectionPoints = [...intersectionPoints_lfp, ...intersectionPoints_mc, ...intersectionPoints_rfp];
                    // 按x坐标排序并去重
                    intersectionPoints = intersectionPoints
                        .sort((a, b) => a.x - b.x)
                        .filter((point, index, self) =>
                            index === 0 || Math.abs(point.x - self[index - 1].x) > 0.001
                        );
                    
                    // 通过总流量和总断面面积计算水力半径
                    if (A_final > 0 && Q_final > 0 && n_mc_val > 0 && i_val > 0) {
                        R_final = Math.pow((Q_final * n_mc_val) / (A_final * Math.pow(i_val, 0.5)), 1.5);
                        P_final = (R_final > 0 && isFinite(R_final)) ? A_final / R_final : Infinity;
                    } else if (A_final > 0) {
                        R_final = 0;
                        P_final = Infinity; 
                    } else { 
                        R_final = 0;
                        P_final = 0;
                    }
                }
                
                // 保存结果
                if (A_final > 0 || (A_final === 0 && currentWL >= minY_data)) {
                    if (!(A_final === 0 && Q_final === 0 && P_final === 0 && R_final === 0 && currentWL < minY_data + waterLevelStep * 0.01)) {
                        resultsData.push({
                            wl: currentWL.toFixed(2),
                            a: A_final.toFixed(2),
                            p: P_final === Infinity ? "Inf." : (isFinite(P_final) ? P_final.toFixed(2) : "Inf."),
                            r: R_final.toFixed(2),
                            q: Q_final.toFixed(2),
                            rem: remark,
                            intersectionPoints: intersectionPoints
                        });
                        if (A_final > 0) lastPlottedWL = currentWL;
                     }
                }
            }

            // 显示结果
            if (resultsData.length > 0) {
                resultsData.forEach(data => {
                    const row = resultsTableBody.insertRow();
                    row.addEventListener('click', handleTableRowClick);
                    
                    row.insertCell().textContent = data.wl;
                    row.insertCell().textContent = data.a;
                    row.insertCell().textContent = data.p;
                    row.insertCell().textContent = data.r;
                    row.insertCell().textContent = data.q;
                    const remarkCell = row.insertCell();
                    remarkCell.textContent = data.rem;
                    if (data.rem === "漫滩") {
                        remarkCell.classList.add('remark-flood');
                    } else if (data.rem === "主槽") {
                        remarkCell.classList.add('remark-main');
                    }
                });

                noResultsMessageEl.classList.add('hidden');
                     setStatusMessage(`计算完成，共 ${resultsData.length} 条结果。`, false);

                // 默认选中第一行
                const firstRow = resultsTableBody.firstElementChild;
                if (firstRow) {
                    firstRow.click();
                }
            } else {
                noResultsMessageEl.classList.remove('hidden');
                setStatusMessage('在设定的计算范围内未能得到有效的水力计算结果。请检查输入或调整水位范围。', true);
                drawCrossSection(); 
            }
        }

        // 内部函数：清空所有数据和重置界面
        function _resetAll() {
            sectionDataEl.value = '';
            waterLevelIntervalEl.value = '0.5';
            manningN_mc_El.value = '0.03';
            channelSlopeEl.value = '0.00177'; // Reset to original default
            
            // Clear manual water level controls
            useManualWaterLevelsEl.checked = false;
            manualWaterLevelControlsEl.classList.add('hidden');
            manualStartWLEl.value = '';
            manualEndWLEl.value = '';

            considerFloodplainEl.checked = false;
            floodplainControlsEl.classList.add('hidden');
            
            parsedSectionPoints = [];
            leftBankPointIndex = -1;
            rightBankPointIndex = -1;
            hBankfull = -1;
            resultsData = [];
            intersectionPoints = [];
            updateBankPointInfo();
            
            resultsTableBody.innerHTML = '';
            noResultsMessageEl.classList.add('hidden'); // Ensure this is hidden on clear
            setStatusMessage('所有输入已清空。', false);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCrossSection(null, null); // 清除参数框
            document.getElementById('parameterDisplay').classList.add('hidden');
        }

        function copyResultsToClipboard() {
            const rows = Array.from(resultsTableBody.rows);
            if (rows.length === 0) {
                setStatusMessage('没有结果可以复制。', true);
                return;
            }
            const header = Array.from(document.getElementById('resultsTable').getElementsByTagName('th'))
                                .map(th => th.textContent).join('\t');
            const data = rows.map(row => 
                Array.from(row.cells).map(cell => cell.textContent).join('\t')
            ).join('\n');
            
            const fullText = header + '\n' + data;

            navigator.clipboard.writeText(fullText).then(() => {
                setStatusMessage('结果已复制到剪贴板。', false);
            }).catch(err => {
                setStatusMessage('复制失败: ' + err, true);
                // Fallback for browsers that might restrict clipboard API in iframes or secure contexts
                try {
                    const textArea = document.createElement("textarea");
                    textArea.value = fullText;
                    textArea.style.position = "fixed"; // Prevent scrolling to bottom of page
                    textArea.style.top = "0";
                    textArea.style.left = "0";
                    textArea.style.opacity = "0"; // Make it invisible
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    setStatusMessage('结果已复制到剪贴板 (fallback)。', false);
                } catch (e) {
                    setStatusMessage('复制失败，请手动选择复制。 ' + e, true);
                }
            });
        }
        
        function setStatusMessage(message, isError = false) {
            statusMessageEl.textContent = message;
            statusMessageEl.className = 'mt-2 p-3 rounded-md text-sm'; // Reset classes
            if (isError) {
                statusMessageEl.classList.add('error');
            } else {
                statusMessageEl.classList.add('success');
            }
        }

        // 添加表格行点击事件处理
        function handleTableRowClick(event) {
            const row = event.currentTarget;
            const cells = row.cells;
            
            // 移除其他行的选中状态
            const allRows = resultsTableBody.getElementsByTagName('tr');
            Array.from(allRows).forEach(r => r.classList.remove('selected'));
            
            // 添加当前行的选中状态
            row.classList.add('selected');
            
            // 获取该行的数据
            const rowIndex = Array.from(allRows).indexOf(row);
            const selectedData = {
                wl: cells[0].textContent,
                a: cells[1].textContent,
                p: cells[2].textContent,
                r: cells[3].textContent,
                q: cells[4].textContent,
                rem: cells[5].textContent,
                intersectionPoints: resultsData[rowIndex].intersectionPoints // 从存储的数据中获取交点信息
            };
            
            // 重绘断面图，传入选中的水位和数据
            drawCrossSection(parseFloat(selectedData.wl), selectedData);
        }

        function updateQHPlot() {
            const dpr = window.devicePixelRatio || 1;
            const rect = qhCanvas.getBoundingClientRect();
            qhCanvas.width = rect.width * dpr;
            qhCanvas.height = rect.height * dpr;
            qhCtx.scale(dpr, dpr);

            // 获取计算结果数据
            const rows = Array.from(resultsTableBody.rows);
            if (rows.length === 0) {
                setStatusMessage('没有数据可以绘制。', true);
                return;
            }

            // 提取水位和流量数据
            const data = rows.map(row => ({
                h: parseFloat(row.cells[0].textContent),
                q: parseFloat(row.cells[4].textContent)
            })).filter(d => !isNaN(d.h) && !isNaN(d.q));

            // 计算数据范围
            const qMin = Math.min(...data.map(d => d.q));
            const qMax = Math.max(...data.map(d => d.q));
            const hMin = Math.min(...data.map(d => d.h));
            const hMax = Math.max(...data.map(d => d.h));

            // 使用配置或自动计算的轴范围
            const xMin = qhPlotConfig.xAxis.min ?? qMin;
            const xMax = qhPlotConfig.xAxis.max ?? qMax;
            const yMin = qhPlotConfig.yAxis.min ?? hMin;
            const yMax = qhPlotConfig.yAxis.max ?? hMax;

            // 设置绘图区域
            const padding = 60;
            const width = qhCanvas.width / dpr - 2 * padding;
            const height = qhCanvas.height / dpr - 2 * padding;

            // 坐标转换函数
            const toCanvasX = q => padding + (q - xMin) * width / (xMax - xMin);
            const toCanvasY = h => qhCanvas.height / dpr - padding - (h - yMin) * height / (yMax - yMin);

            // 清空画布
            qhCtx.clearRect(0, 0, qhCanvas.width / dpr, qhCanvas.height / dpr);

            // 绘制网格
            if (qhPlotConfig.showGrid) {
                const xStep = qhPlotConfig.xAxis.step ?? calculateNiceNumber((xMax - xMin) / 10, true);
                const yStep = qhPlotConfig.yAxis.step ?? calculateNiceNumber((yMax - yMin) / 10, true);

                qhCtx.beginPath();
                qhCtx.strokeStyle = '#f3f4f6';
                qhCtx.lineWidth = 1;

                // 垂直网格线
                for (let q = Math.ceil(xMin / xStep) * xStep; q <= xMax; q += xStep) {
                    const x = toCanvasX(q);
                    qhCtx.moveTo(x, padding);
                    qhCtx.lineTo(x, qhCanvas.height / dpr - padding);
                }

                // 水平网格线
                for (let h = Math.ceil(yMin / yStep) * yStep; h <= yMax; h += yStep) {
                    const y = toCanvasY(h);
                    qhCtx.moveTo(padding, y);
                    qhCtx.lineTo(qhCanvas.width / dpr - padding, y);
                }
                qhCtx.stroke();
            }

            // 绘制坐标轴
            qhCtx.beginPath();
            qhCtx.strokeStyle = '#9ca3af';
            qhCtx.lineWidth = 1.5;
            // X轴
            qhCtx.moveTo(padding, qhCanvas.height / dpr - padding);
            qhCtx.lineTo(qhCanvas.width / dpr - padding, qhCanvas.height / dpr - padding);
            // Y轴
            qhCtx.moveTo(padding, padding);
            qhCtx.lineTo(padding, qhCanvas.height / dpr - padding);
            qhCtx.stroke();

            // 绘制刻度和标签
            qhCtx.fillStyle = '#4b5563';
            qhCtx.font = '12px Inter';

            // X轴（流量）刻度和标签
            const xStep = qhPlotConfig.xAxis.step ?? calculateNiceNumber((xMax - xMin) / 10, true);
            for (let q = Math.ceil(xMin / xStep) * xStep; q <= xMax; q += xStep) {
                const x = toCanvasX(q);
                qhCtx.beginPath();
                qhCtx.moveTo(x, qhCanvas.height / dpr - padding);
                qhCtx.lineTo(x, qhCanvas.height / dpr - padding + 5);
                qhCtx.stroke();
                qhCtx.textAlign = 'center';
                qhCtx.fillText(q.toFixed(2), x, qhCanvas.height / dpr - padding + 20);
            }

            // Y轴（水位）刻度和标签
            const yStep = qhPlotConfig.yAxis.step ?? calculateNiceNumber((yMax - yMin) / 10, true);
            for (let h = Math.ceil(yMin / yStep) * yStep; h <= yMax; h += yStep) {
                const y = toCanvasY(h);
                qhCtx.beginPath();
                qhCtx.moveTo(padding - 5, y);
                qhCtx.lineTo(padding, y);
                qhCtx.stroke();
                qhCtx.textAlign = 'right';
                qhCtx.fillText(h.toFixed(2), padding - 8, y + 4);
            }

            // 添加轴标题
            qhCtx.save();
            qhCtx.translate(padding - 40, qhCanvas.height / dpr / 2);
            qhCtx.rotate(-Math.PI / 2);
            qhCtx.textAlign = 'center';
            qhCtx.fillText('水位 (m)', 0, 0);
            qhCtx.restore();

            qhCtx.textAlign = 'center';
            qhCtx.fillText('流量 (m³/s)', qhCanvas.width / dpr / 2, qhCanvas.height / dpr - padding + 35);

            // 绘制数据点和线
            if (qhPlotConfig.smoothLine) {
                // 绘制平滑曲线
                qhCtx.beginPath();
                qhCtx.strokeStyle = '#3b82f6';
                qhCtx.lineWidth = 2;
                
                // 使用三次样条插值
                const points = data.map(d => ({
                    x: toCanvasX(d.q),
                    y: toCanvasY(d.h)
                }));
                
                qhCtx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length - 2; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    qhCtx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                }
                qhCtx.quadraticCurveTo(
                    points[points.length - 2].x,
                    points[points.length - 2].y,
                    points[points.length - 1].x,
                    points[points.length - 1].y
                );
                qhCtx.stroke();
            } else {
                // 绘制折线
                qhCtx.beginPath();
                qhCtx.strokeStyle = '#3b82f6';
                qhCtx.lineWidth = 2;
                data.forEach((d, i) => {
                    const x = toCanvasX(d.q);
                    const y = toCanvasY(d.h);
                    if (i === 0) qhCtx.moveTo(x, y);
                    else qhCtx.lineTo(x, y);
                });
                qhCtx.stroke();
            }

            // 绘制数据点
            if (qhPlotConfig.showPoints) {
                data.forEach(d => {
                    const x = toCanvasX(d.q);
                    const y = toCanvasY(d.h);
                    
                    // 绘制点的外圈（白色边框）
                    qhCtx.beginPath();
                    qhCtx.arc(x, y, 4, 0, 2 * Math.PI);
                    qhCtx.fillStyle = '#ffffff';
                    qhCtx.fill();
                    qhCtx.strokeStyle = '#3b82f6';
                    qhCtx.lineWidth = 2;
                    qhCtx.stroke();
                    
                    // 绘制点的内圈
                    qhCtx.beginPath();
                    qhCtx.arc(x, y, 2, 0, 2 * Math.PI);
                    qhCtx.fillStyle = '#3b82f6';
                    qhCtx.fill();

                    // 绘制数据标签
                    if (qhPlotConfig.showDataLabels) {
                        qhCtx.fillStyle = '#4b5563';
                        qhCtx.textAlign = 'left';
                        qhCtx.textBaseline = 'bottom';
                        qhCtx.fillText(`(${d.q.toFixed(2)}, ${d.h.toFixed(2)})`, x + 8, y - 8);
                    }
                });
            }
        }

        // Initial setup
        handleUpdatePreview(); 
        // Set initial status message if needed, or leave it to be set by actions
        // setStatusMessage("请输入断面数据和参数后点击"预览/更新断面"或"计算"。", false) 

    </script>
</body>
</html>



