<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>断面水位流量关系计算器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style type="text/tailwindcss">
        body { 
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: #f3f4f6;
        }
        .input-label { 
            @apply block text-sm font-medium text-gray-700 mb-1;
        }
        .input-field { 
            @apply mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm 
            focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 
            transition duration-150 ease-in-out;
        }
        .button { 
            @apply px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white 
            focus:outline-none focus:ring-2 focus:ring-offset-2 
            transition duration-150 ease-in-out;
        }
        .button-primary { 
            @apply bg-indigo-600 hover:bg-indigo-700 focus:ring-indigo-500 
            transform hover:scale-105 transition-transform duration-150;
        }
        .button-secondary { 
            @apply bg-gray-600 hover:bg-gray-700 focus:ring-gray-500
            transform hover:scale-105 transition-transform duration-150;
        }
        .button-small { 
            @apply px-2 py-1 text-xs;
        }
        #crossSectionCanvas { 
            @apply border-2 border-gray-200 rounded-lg shadow-lg bg-white;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        .table-wrapper {
            @apply mt-8 bg-white rounded-lg shadow-lg overflow-hidden;
        }
        .table-header {
            @apply px-6 py-4 bg-white border-b border-gray-200;
        }
        .table-container {
            @apply overflow-x-auto;
        }
        table {
            @apply min-w-full divide-y divide-gray-200;
        }
        thead {
            @apply bg-gray-50;
        }
        th {
            @apply px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider 
            border-b border-gray-200 bg-gray-50 sticky top-0;
        }
        td {
            @apply px-6 py-4 whitespace-nowrap text-sm text-gray-600 border-b border-gray-200;
        }
        tbody tr:nth-child(even) {
            @apply bg-gray-50;
        }
        tbody tr:hover {
            @apply bg-blue-50 transition-colors duration-150;
        }
        .remark-flood {
            @apply text-red-600 font-medium;
        }
        .remark-main {
            @apply text-green-600 font-medium;
        }
        #noResultsMessage {
            @apply text-center text-gray-500 py-8 bg-gray-50 border-t border-gray-200;
        }
        #statusMessage { 
            @apply mt-4 p-4 rounded-md text-sm font-medium shadow-sm;
        }
        .error { 
            @apply bg-red-50 text-red-700 border border-red-200;
        }
        .success { 
            @apply bg-green-50 text-green-700 border border-green-200;
        }
        .card {
            @apply bg-white rounded-lg shadow-lg p-6 border border-gray-100;
        }
        .section-title {
            @apply text-lg font-semibold text-gray-800 mb-4;
        }
        .checkbox-wrapper {
            @apply flex items-center space-x-2 p-2 rounded-md hover:bg-gray-50 transition-colors duration-150;
        }
        input[type="checkbox"] {
            @apply w-4 h-4 text-indigo-600 border-gray-300 rounded 
            focus:ring-indigo-500 cursor-pointer;
        }
        tbody tr {
            @apply cursor-pointer transition-all duration-150;
        }
        tbody tr.selected {
            @apply bg-indigo-100 !important;
        }
        tbody tr:hover:not(.selected) {
            @apply bg-indigo-50;
        }
        .parameter-box {
            @apply absolute bg-white/90 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-gray-200 
            text-sm text-gray-700 transition-opacity duration-150;
        }
        .parameter-value {
            @apply font-medium text-indigo-600;
        }
        .main-container {
            @apply grid grid-cols-3 gap-6;
        }
        .left-section {
            @apply col-span-2 space-y-6;
        }
        .right-section {
            @apply col-span-1;
        }
        .params-section {
            @apply grid grid-cols-2 gap-6;
        }
        .params-box {
            @apply bg-white/95 backdrop-blur-sm py-2 px-4 rounded-lg shadow-sm border border-gray-200 
            flex items-center justify-start space-x-4 text-sm;
        }
        .param-item {
            @apply flex items-center space-x-2 text-gray-600;
        }
        .param-value {
            @apply font-medium text-indigo-600;
        }
    </style>
</head>
<body class="bg-gray-50 p-4 md:p-8">
    <div class="container mx-auto max-w-10xl">
        <h1 class="text-3xl font-bold text-center text-indigo-700 mb-8">断面水位流量关系计算器</h1>

        <div class="main-container">
            <div class="left-section">
                <!-- 上部参数区域 -->
                <div class="params-section">
                    <!-- 基本参数 -->
                    <div class="card">
                        <h2 class="section-title">基本参数</h2>
                        <div class="space-y-4">
                            <div>
                                <label for="sectionData" class="input-label">断面数据 (X Y 坐标, 每行一对):</label>
                                <textarea id="sectionData" rows="8" class="input-field font-mono text-sm" placeholder="例如:&#10;0 100&#10;10 95&#10;20 92&#10;30 95&#10;40 100">0	88
10	84.813
40	84.813
51.279	84.81
51.657	85.069
53.462	84.694
55.898	82.977
57.978	81.9
60.126	81.23
62.555	80.77
66.298	80.75
70.061	80.95
73.248	81.15
75.808	81.9
77.505	83.583
78.55	83.958
82.581	85.823
84.542	85.927
85.186	85.732
94.934	85.83
96.465	86.721
99.923	86.734
100	88</textarea>
                            </div>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="waterLevelInterval" class="input-label">水位间隔 (a, m):</label>
                                    <input type="number" id="waterLevelInterval" class="input-field" value="0.5" step="0.1">
                                </div>
                                <div>
                                    <label for="manningN" class="input-label">曼宁糙率系数 (n):</label>
                                    <input type="number" id="manningN" class="input-field" value="0.03" step="0.001">
                                </div>
                            </div>
                            <div>
                                <label for="channelSlope" class="input-label">河道坡降 (i, S0):</label>
                                <input type="number" id="channelSlope" class="input-field" value="0.00177" step="0.0001">
                            </div>
                        </div>
                    </div>

                    <!-- 计算选项 -->
                    <div class="card">
                        <h2 class="section-title">计算选项</h2>
                        <div class="space-y-4">
                            <div class="checkbox-wrapper">
                                <input id="useManualWaterLevels" type="checkbox">
                                <label for="useManualWaterLevels" class="text-sm text-gray-700">手动设定计算水位范围</label>
                            </div>
                            <div id="manualWaterLevelControls" class="hidden space-y-4 pl-6">
                                <div>
                                    <label for="manualStartWL" class="input-label">手动起始水位 (m):</label>
                                    <input type="number" id="manualStartWL" class="input-field" step="0.1" placeholder="例如: 80.0">
                                </div>
                                <div>
                                    <label for="manualEndWL" class="input-label">手动终止水位 (m):</label>
                                    <input type="number" id="manualEndWL" class="input-field" step="0.1" placeholder="例如: 88.0">
                                </div>
                            </div>

                            <div class="checkbox-wrapper">
                                <input id="considerFloodplain" type="checkbox">
                                <label for="considerFloodplain" class="text-sm text-gray-700">考虑漫滩计算</label>
                            </div>

                            <div id="floodplainControls" class="hidden space-y-4 pl-6">
                                <p class="text-sm text-gray-600 font-medium">调整主槽岸顶 (红点):</p>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label class="input-label">左岸顶:</label>
                                        <div class="flex space-x-2">
                                            <button id="leftBankPrev" class="button button-secondary button-small">← 左移</button>
                                            <button id="leftBankNext" class="button button-secondary button-small">右移 →</button>
                                        </div>
                                        <p id="leftBankInfo" class="text-xs text-gray-500 mt-1">-</p>
                                    </div>
                                    <div>
                                        <label class="input-label">右岸顶:</label>
                                        <div class="flex space-x-2">
                                            <button id="rightBankPrev" class="button button-secondary button-small">← 左移</button>
                                            <button id="rightBankNext" class="button button-secondary button-small">右移 →</button>
                                        </div>
                                        <p id="rightBankInfo" class="text-xs text-gray-500 mt-1">-</p>
                                    </div>
                                </div>
                                <p id="hBankfullInfo" class="text-sm font-medium text-indigo-600">临界岸顶高程: -</p>
                            </div>

                            <div class="pt-4 border-t border-gray-200 mt-4">
                                <div class="flex space-x-4">
                                    <button id="updatePreviewButton" class="button button-primary flex-1">
                                        <span class="flex items-center justify-center">
                                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                            </svg>
                                            预览/更新断面
                                        </span>
                                    </button>
                                    <button id="calculateButton" class="button button-primary bg-green-600 hover:bg-green-700 flex-1">
                                        <span class="flex items-center justify-center">
                                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                                            </svg>
                                            计算
                                        </span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 下部绘图区域 -->
                <div class="card">
                    <div id="parameterDisplay" class="mb-4 hidden params-box">
                        <div class="param-item">
                            <span>过水面积:</span>
                            <span class="param-value" id="paramArea">-</span>
                            <span>m²</span>
                        </div>
                        <div class="param-item">
                            <span>湿周:</span>
                            <span class="param-value" id="paramPerimeter">-</span>
                            <span>m</span>
                        </div>
                        <div class="param-item">
                            <span>流量:</span>
                            <span class="param-value" id="paramFlow">-</span>
                            <span>m³/s</span>
                        </div>
                    </div>
                    <canvas id="crossSectionCanvas" width="800" height="500" class="w-full h-auto"></canvas>
                    <div id="statusMessage" class="mt-4"></div>
                </div>
            </div>

            <!-- 右侧结果表格 -->
            <div class="right-section">
                <div class="table-wrapper h-full flex flex-col">
                    <div class="table-header flex-none">
                        <div class="flex justify-between items-center">
                            <h2 class="section-title mb-0">计算结果</h2>
                            <div class="space-x-3">
                                <button id="copyResultsButton" class="button button-secondary">
                                    <span class="flex items-center">
                                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                        </svg>
                                        复制结果
                                    </span>
                                </button>
                                <button id="clearAllButton" class="button button-secondary bg-red-600 hover:bg-red-700">
                                    <span class="flex items-center">
                                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                        </svg>
                                        清空全部
                                    </span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="table-container flex-1 overflow-auto" style="max-height: calc(100vh - 400px);">
                        <table id="resultsTable" class="w-full">
                            <thead class="sticky top-0 bg-gray-50 shadow-sm">
                                <tr>
                                    <th>水位 (m)</th>
                                    <th>过水面积 (m²)</th>
                                    <th>湿周 (m)</th>
                                    <th>水力半径 (m)</th>
                                    <th>流量 (m³/s)</th>
                                    <th>备注</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div id="noResultsMessage" class="hidden">无计算结果</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 水位流量关系图区域 -->
        <div class="mt-8">
            <h2 class="text-2xl font-bold text-center text-indigo-700 mb-6">水位流量关系图</h2>
            <div class="grid grid-cols-4 gap-6">
                <!-- 左侧绘图区 -->
                <div class="col-span-3">
                    <div class="card">
                        <canvas id="qhCanvas" width="800" height="500" class="w-full h-auto"></canvas>
                    </div>
                </div>
                
                <!-- 右侧配置面板 -->
                <div class="col-span-1">
                    <div class="card space-y-6">
                        <h3 class="text-lg font-semibold text-gray-800">图表设置</h3>
                        
                        <!-- 基本显示设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">基本设置</h4>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showGrid" checked>
                                <label for="showGrid">显示网格</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showPoints" checked>
                                <label for="showPoints">显示数据点</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="showDataLabels">
                                <label for="showDataLabels">显示数据标签</label>
                            </div>
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="smoothLine">
                                <label for="smoothLine">平滑曲线</label>
                            </div>
                        </div>

                        <!-- 流量轴（X轴）设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">流量轴设置（横轴）</h4>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="input-label">最小值</label>
                                    <input type="number" id="xAxisMin" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">最大值</label>
                                    <input type="number" id="xAxisMax" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">主刻度间距</label>
                                    <input type="number" id="xAxisStep" class="input-field" placeholder="自动">
                                </div>
                            </div>
                        </div>

                        <!-- 水位轴（Y轴）设置 -->
                        <div class="space-y-3">
                            <h4 class="font-medium text-gray-700">水位轴设置（纵轴）</h4>
                            <div class="grid grid-cols-2 gap-2">
                                <div>
                                    <label class="input-label">最小值</label>
                                    <input type="number" id="yAxisMin" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">最大值</label>
                                    <input type="number" id="yAxisMax" class="input-field" placeholder="自动">
                                </div>
                                <div>
                                    <label class="input-label">主刻度间距</label>
                                    <input type="number" id="yAxisStep" class="input-field" placeholder="自动">
                                </div>
                            </div>
                        </div>

                        <!-- 图表操作按钮 -->
                        <div class="pt-4 border-t border-gray-200">
                            <button id="updateQHPlotButton" class="button button-primary w-full">
                                <span class="flex items-center justify-center">
                                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                    更新图表
                                </span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let parsedSectionPoints = [];
        let leftBankPointIndex = -1;
        let rightBankPointIndex = -1;
        let hBankfull = -1; // This will store min(YL, YR) when floodplain is active

        const canvas = document.getElementById('crossSectionCanvas');
        const ctx = canvas.getContext('2d');

        // DOM Elements
        const sectionDataEl = document.getElementById('sectionData');
        const waterLevelIntervalEl = document.getElementById('waterLevelInterval');
        const manningNEl = document.getElementById('manningN');
        const channelSlopeEl = document.getElementById('channelSlope');
        const considerFloodplainEl = document.getElementById('considerFloodplain');
        const floodplainControlsEl = document.getElementById('floodplainControls');
        const leftBankInfoEl = document.getElementById('leftBankInfo');
        const rightBankInfoEl = document.getElementById('rightBankInfo');
        const hBankfullInfoEl = document.getElementById('hBankfullInfo');
        const resultsTableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
        const statusMessageEl = document.getElementById('statusMessage');
        const noResultsMessageEl = document.getElementById('noResultsMessage');

        // New DOM Elements for manual water level control
        const useManualWaterLevelsEl = document.getElementById('useManualWaterLevels');
        const manualWaterLevelControlsEl = document.getElementById('manualWaterLevelControls');
        const manualStartWLEl = document.getElementById('manualStartWL');
        const manualEndWLEl = document.getElementById('manualEndWL');

        // 水位流量关系图相关变量
        const qhCanvas = document.getElementById('qhCanvas');
        const qhCtx = qhCanvas.getContext('2d');
        let qhPlotConfig = {
            showGrid: true,
            showPoints: true,
            showDataLabels: false,
            smoothLine: false,
            xAxis: {
                min: null,
                max: null,
                step: null
            },
            yAxis: {
                min: null,
                max: null,
                step: null
            }
        };

        // Event Listeners
        document.getElementById('updatePreviewButton').addEventListener('click', handleUpdatePreview);
        document.getElementById('calculateButton').addEventListener('click', handleCalculate);
        document.getElementById('clearAllButton').addEventListener('click', clearAll);
        document.getElementById('copyResultsButton').addEventListener('click', copyResultsToClipboard);
        
        considerFloodplainEl.addEventListener('change', () => {
            floodplainControlsEl.classList.toggle('hidden', !considerFloodplainEl.checked);
            if (considerFloodplainEl.checked && parsedSectionPoints.length > 0) {
                suggestInitialBankPoints(); 
            } else {
                leftBankPointIndex = -1;
                rightBankPointIndex = -1;
                hBankfull = -1; 
                updateBankPointInfo(); 
            }
            drawCrossSection();
        });

        // Event listener for the new manual water level checkbox
        useManualWaterLevelsEl.addEventListener('change', () => {
            manualWaterLevelControlsEl.classList.toggle('hidden', !useManualWaterLevelsEl.checked);
        });

        document.getElementById('leftBankPrev').addEventListener('click', () => adjustBankPoint('left', -1));
        document.getElementById('leftBankNext').addEventListener('click', () => adjustBankPoint('left', 1));
        document.getElementById('rightBankPrev').addEventListener('click', () => adjustBankPoint('right', -1));
        document.getElementById('rightBankNext').addEventListener('click', () => adjustBankPoint('right', 1));

        // 绑定配置面板事件
        document.getElementById('showGrid').addEventListener('change', e => {
            qhPlotConfig.showGrid = e.target.checked;
            updateQHPlot();
        });
        document.getElementById('showPoints').addEventListener('change', e => {
            qhPlotConfig.showPoints = e.target.checked;
            updateQHPlot();
        });
        document.getElementById('showDataLabels').addEventListener('change', e => {
            qhPlotConfig.showDataLabels = e.target.checked;
            updateQHPlot();
        });
        document.getElementById('smoothLine').addEventListener('change', e => {
            qhPlotConfig.smoothLine = e.target.checked;
            updateQHPlot();
        });
        document.getElementById('updateQHPlotButton').addEventListener('click', updateQHPlot);

        ['x', 'y'].forEach(axis => {
            ['Min', 'Max', 'Step'].forEach(prop => {
                const input = document.getElementById(`${axis}Axis${prop}`);
                input.addEventListener('change', e => {
                    const value = e.target.value === '' ? null : parseFloat(e.target.value);
                    qhPlotConfig[`${axis}Axis`][prop.toLowerCase()] = value;
                    updateQHPlot();
                });
            });
        });

        // --- Core Logic ---

        function parseSectionData() {
            const data = sectionDataEl.value.trim();
            if (!data) {
                setStatusMessage('断面数据不能为空。', true);
                parsedSectionPoints = []; 
                return false;
            }
            const lines = data.split('\n');
            parsedSectionPoints = [];
            for (let i = 0; i < lines.length; i++) {
                const parts = lines[i].trim().split(/\s+/);
                if (parts.length === 2) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    if (!isNaN(x) && !isNaN(y)) {
                        parsedSectionPoints.push({ x, y, originalIndex: i });
                    } else {
                        setStatusMessage(`数据格式错误在行 ${i+1}: "${lines[i]}"`, true);
                        return false;
                    }
                } else if (lines[i].trim() !== "") { 
                     setStatusMessage(`数据格式错误在行 ${i+1}: "${lines[i]}" (应为 X Y)`, true);
                    return false;
                }
            }

            if (parsedSectionPoints.length < 2) {
                setStatusMessage('断面数据至少需要两个点。', true);
                return false;
            }

            parsedSectionPoints.sort((a, b) => a.x - b.x);
            setStatusMessage('断面数据解析成功。', false);
            return true;
        }

        function suggestInitialBankPoints() {
            if (parsedSectionPoints.length < 3) { 
                leftBankPointIndex = 0;
                rightBankPointIndex = parsedSectionPoints.length > 1 ? 1 : 0;
            } else {
                let lowestY = Infinity;
                let lowestIdx = -1;
                parsedSectionPoints.forEach((p, idx) => {
                    if (p.y < lowestY) {
                        lowestY = p.y;
                        lowestIdx = idx;
                    }
                });

                if (lowestIdx !== -1) {
                    const quarterLength = Math.max(1, Math.floor(parsedSectionPoints.length / 5)); 
                    leftBankPointIndex = Math.max(0, lowestIdx - quarterLength);
                    rightBankPointIndex = Math.min(parsedSectionPoints.length - 1, lowestIdx + quarterLength);

                    if (leftBankPointIndex >= rightBankPointIndex) { 
                       if (lowestIdx > 0) {
                           leftBankPointIndex = lowestIdx -1;
                           if (lowestIdx < parsedSectionPoints.length -1) {
                               rightBankPointIndex = lowestIdx + 1;
                           } else {
                               rightBankPointIndex = lowestIdx; 
                               if (leftBankPointIndex === rightBankPointIndex && leftBankPointIndex > 0) leftBankPointIndex--; 
                           }
                       } else if (lowestIdx < parsedSectionPoints.length -1) { 
                           leftBankPointIndex = lowestIdx;
                           rightBankPointIndex = lowestIdx + 1;
                       } else { 
                           leftBankPointIndex = 0;
                           rightBankPointIndex = parsedSectionPoints.length > 1 ? 1: 0;
                       }
                    }
                } else { 
                    leftBankPointIndex = Math.floor(parsedSectionPoints.length / 3);
                    rightBankPointIndex = Math.floor(2 * parsedSectionPoints.length / 3);
                }
            }
             if (leftBankPointIndex === rightBankPointIndex && parsedSectionPoints.length > 1) {
                if (rightBankPointIndex < parsedSectionPoints.length - 1) rightBankPointIndex++;
                else if (leftBankPointIndex > 0) leftBankPointIndex--;
            }
            updateBankPointInfo();
        }
        
        function adjustBankPoint(side, direction) {
            if (!considerFloodplainEl.checked || parsedSectionPoints.length === 0) return;

            if (side === 'left') {
                const newIndex = leftBankPointIndex + direction;
                if (newIndex >= 0 && newIndex < (rightBankPointIndex === -1 ? parsedSectionPoints.length -1 : rightBankPointIndex) ) {
                    leftBankPointIndex = newIndex;
                }
            } else if (side === 'right') {
                const newIndex = rightBankPointIndex + direction;
                if (newIndex < parsedSectionPoints.length && newIndex > (leftBankPointIndex === -1 ? 0 : leftBankPointIndex) ) {
                    rightBankPointIndex = newIndex;
                }
            }
            updateBankPointInfo();
            drawCrossSection();
        }

        function updateBankPointInfo() {
            const ptL = (leftBankPointIndex !== -1 && parsedSectionPoints[leftBankPointIndex]) ? parsedSectionPoints[leftBankPointIndex] : null;
            const ptR = (rightBankPointIndex !== -1 && parsedSectionPoints[rightBankPointIndex]) ? parsedSectionPoints[rightBankPointIndex] : null;

            if (ptL) {
                leftBankInfoEl.textContent = `X:${ptL.x.toFixed(2)}, Y:${ptL.y.toFixed(2)} (点 ${leftBankPointIndex})`;
            } else {
                leftBankInfoEl.textContent = '-';
            }

            if (ptR) {
                rightBankInfoEl.textContent = `X:${ptR.x.toFixed(2)}, Y:${ptR.y.toFixed(2)} (点 ${rightBankPointIndex})`;
            } else {
                rightBankInfoEl.textContent = '-';
            }

            if (considerFloodplainEl.checked && ptL && ptR) {
                hBankfull = Math.min(ptL.y, ptR.y);
                hBankfullInfoEl.textContent = `临界岸顶高程 (Hbankfull): ${hBankfull.toFixed(2)} m`;
            } else {
                hBankfull = -1; 
                hBankfullInfoEl.textContent = '临界岸顶高程 (Hbankfull): -';
            }
        }

        function calculateNiceNumber(range, round) {
            const exponent = Math.floor(Math.log10(range));
            const fraction = range / Math.pow(10, exponent);
            let niceFraction;

            if (round) {
                if (fraction < 1.5) niceFraction = 1;
                else if (fraction < 3) niceFraction = 2;
                else if (fraction < 7) niceFraction = 5;
                else niceFraction = 10;
            } else {
                if (fraction <= 1) niceFraction = 1;
                else if (fraction <= 2) niceFraction = 2;
                else if (fraction <= 5) niceFraction = 5;
                else niceFraction = 10;
            }

            return niceFraction * Math.pow(10, exponent);
        }

        function calculateAxisParameters(min, max) {
            const range = calculateNiceNumber(max - min, false);
            const tickSpacing = calculateNiceNumber(range / (8 - 1), true);
            const niceMin = Math.floor(min / tickSpacing) * tickSpacing;
            const niceMax = Math.ceil(max / tickSpacing) * tickSpacing;

            return {
                min: niceMin,
                max: niceMax,
                tickSpacing: tickSpacing
            };
        }

        function drawCrossSection(currentWaterLevel = null, selectedData = null) {
            // 设置canvas的DPI以提高清晰度
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (parsedSectionPoints.length < 2) return;

            const padding = 60; // 增加padding以便更好地显示坐标轴标签
            const viewWidth = canvas.width / dpr - 2 * padding;
            const viewHeight = canvas.height / dpr - 2 * padding;

            let minX_data = parsedSectionPoints[0].x;
            let maxX_data = parsedSectionPoints[parsedSectionPoints.length - 1].x;
            let minY_data = Infinity, maxY_data = -Infinity;
            parsedSectionPoints.forEach(p => {
                minY_data = Math.min(minY_data, p.y);
                maxY_data = Math.max(maxY_data, p.y);
            });
            
            let plotMinY = minY_data;
            let plotMaxY = maxY_data;

            if (currentWaterLevel !== null) {
                plotMaxY = Math.max(plotMaxY, currentWaterLevel);
                plotMinY = Math.min(plotMinY, currentWaterLevel);
            }
            if (hBankfull !== -1 && considerFloodplainEl.checked) {
                plotMaxY = Math.max(plotMaxY, hBankfull);
                if (leftBankPointIndex !== -1 && parsedSectionPoints[leftBankPointIndex]) {
                    plotMaxY = Math.max(plotMaxY, parsedSectionPoints[leftBankPointIndex].y);
                }
                if (rightBankPointIndex !== -1 && parsedSectionPoints[rightBankPointIndex]) {
                    plotMaxY = Math.max(plotMaxY, parsedSectionPoints[rightBankPointIndex].y);
                }
            }

            const yRange = plotMaxY - plotMinY;
            const yBuffer = Math.max(yRange * 0.1, 0.1);
            plotMinY -= yBuffer;
            plotMaxY += yBuffer;
            if (plotMaxY === plotMinY) {
                plotMinY -= 1;
                plotMaxY += 1;
            }

            // 计算坐标轴的合理范围和间隔
            const xAxisParams = calculateAxisParameters(minX_data, maxX_data);
            const yAxisParams = calculateAxisParameters(plotMinY, plotMaxY);

            // 更新绘图范围
            minX_data = xAxisParams.min;
            maxX_data = xAxisParams.max;
            plotMinY = yAxisParams.min;
            plotMaxY = yAxisParams.max;

            const scaleX = viewWidth / (maxX_data - minX_data);
            const scaleY = viewHeight / (plotMaxY - plotMinY);

            const toCanvasX = (worldX) => padding + (worldX - minX_data) * scaleX;
            const toCanvasY = (worldY) => canvas.height / dpr - padding - (worldY - plotMinY) * scaleY;

            // 绘制坐标轴
            ctx.beginPath();
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            
            // 绘制网格线
            const gridColor = '#f3f4f6';
            const xTicks = Math.round((maxX_data - minX_data) / xAxisParams.tickSpacing);
            const yTicks = Math.round((plotMaxY - plotMinY) / yAxisParams.tickSpacing);
            
            ctx.beginPath();
            for (let i = 0; i <= xTicks; i++) {
                const x = padding + (viewWidth * i) / xTicks;
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height / dpr - padding);
            }
            for (let i = 0; i <= yTicks; i++) {
                const y = padding + (viewHeight * i) / yTicks;
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width / dpr - padding, y);
            }
            ctx.strokeStyle = gridColor;
            ctx.stroke();

            // 绘制坐标轴
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height / dpr - padding);
            ctx.lineTo(canvas.width / dpr - padding, canvas.height / dpr - padding);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height / dpr - padding);
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // 绘制标签
            ctx.fillStyle = '#4b5563';
            ctx.font = '12px Inter';
            
            // X轴标签
            for (let i = 0; i <= xTicks; i++) {
                const val = minX_data + i * xAxisParams.tickSpacing;
                const xPos = toCanvasX(val);
                ctx.textAlign = "center";
                ctx.fillText(val.toFixed(0), xPos, canvas.height / dpr - padding + 20);
                
                ctx.beginPath();
                ctx.moveTo(xPos, canvas.height / dpr - padding);
                ctx.lineTo(xPos, canvas.height / dpr - padding + 5);
                ctx.strokeStyle = '#9ca3af';
                ctx.stroke();
            }
            
            // Y轴标签
            for (let i = 0; i <= yTicks; i++) {
                const val = plotMinY + i * yAxisParams.tickSpacing;
                const yPos = toCanvasY(val);
                ctx.textAlign = "right";
                ctx.fillText(val.toFixed(2), padding - 8, yPos + 4);
                
                ctx.beginPath();
                ctx.moveTo(padding - 5, yPos);
                ctx.lineTo(padding, yPos);
                ctx.strokeStyle = '#9ca3af';
                ctx.stroke();
            }

            // 添加轴标题
            ctx.save();
            ctx.translate(padding - 40, canvas.height / dpr / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = "center";
            ctx.fillText("高程 (m)", 0, 0);
            ctx.restore();
            
            ctx.textAlign = "center";
            ctx.fillText("距离 (m)", canvas.width / dpr / 2, canvas.height / dpr - padding + 35);

            // 绘制断面线
            ctx.beginPath();
            ctx.moveTo(toCanvasX(parsedSectionPoints[0].x), toCanvasY(parsedSectionPoints[0].y));
            parsedSectionPoints.forEach(p => {
                ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
            });
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 填充断面下方区域
            ctx.beginPath();
            ctx.moveTo(toCanvasX(parsedSectionPoints[0].x), toCanvasY(parsedSectionPoints[0].y));
            parsedSectionPoints.forEach(p => {
                ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
            });
            ctx.lineTo(toCanvasX(parsedSectionPoints[parsedSectionPoints.length - 1].x), toCanvasY(plotMinY));
            ctx.lineTo(toCanvasX(parsedSectionPoints[0].x), toCanvasY(plotMinY));
            ctx.closePath();
            ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
            ctx.fill();

            // 绘制断面点
            parsedSectionPoints.forEach((p, index) => {
                const x = toCanvasX(p.x);
                const y = toCanvasY(p.y);
                
                // 绘制点的外圈（白色边框）
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制点的内圈
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fillStyle = '#3b82f6';
                ctx.fill();

                // 可选：每隔几个点显示一个序号
                if (parsedSectionPoints.length <= 30 || index % Math.ceil(parsedSectionPoints.length / 15) === 0) {
                    ctx.fillStyle = '#6B7280';
                    ctx.font = '10px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(`${index + 1}`, x, y - 8);
                }
            });

            // 绘制岸顶点和水位线
            if (considerFloodplainEl.checked) {
                const ptL = (leftBankPointIndex !== -1 && parsedSectionPoints[leftBankPointIndex]) ? parsedSectionPoints[leftBankPointIndex] : null;
                const ptR = (rightBankPointIndex !== -1 && parsedSectionPoints[rightBankPointIndex]) ? parsedSectionPoints[rightBankPointIndex] : null;

                if (ptL) {
                    ctx.beginPath();
                    ctx.arc(toCanvasX(ptL.x), toCanvasY(ptL.y), 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#ef4444';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                if (ptR) {
                    ctx.beginPath();
                    ctx.arc(toCanvasX(ptR.x), toCanvasY(ptR.y), 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#ef4444';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                if (hBankfull !== -1 && hBankfull >= plotMinY && hBankfull <= plotMaxY) {
                    ctx.beginPath();
                    ctx.moveTo(padding, toCanvasY(hBankfull));
                    ctx.lineTo(canvas.width / dpr - padding, toCanvasY(hBankfull));
                    ctx.strokeStyle = 'rgba(239, 68, 68, 0.7)';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // 添加标签背景
                    const label = `岸顶高程: ${hBankfull.toFixed(2)}`;
                    const labelWidth = ctx.measureText(label).width + 10;
                    const labelX = canvas.width / dpr - padding - labelWidth - 10;
                    const labelY = toCanvasY(hBankfull) - 20;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(labelX - 5, labelY - 12, labelWidth + 10, 24);
                    
                    ctx.fillStyle = '#ef4444';
                    ctx.textAlign = "left";
                    ctx.fillText(label, labelX, labelY + 4);
                }
            }

            // 绘制水位线
            if (currentWaterLevel !== null && currentWaterLevel >= plotMinY && currentWaterLevel <= plotMaxY) {
                ctx.beginPath();
                ctx.moveTo(padding, toCanvasY(currentWaterLevel));
                ctx.lineTo(canvas.width / dpr - padding, toCanvasY(currentWaterLevel));
                ctx.strokeStyle = '#06b6d4';
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);

                // 添加水位标签背景
                const label = `水位: ${currentWaterLevel.toFixed(2)}m`;
                const labelWidth = ctx.measureText(label).width + 10;
                const labelX = padding + 10;
                const labelY = toCanvasY(currentWaterLevel) - 20;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(labelX - 5, labelY - 12, labelWidth + 10, 24);

                ctx.fillStyle = '#0891b2';
                ctx.textAlign = "left";
                ctx.fillText(label, labelX, labelY + 4);

                // 填充水位以下区域
                ctx.beginPath();
                let startPoint = null;
                let inWater = false;

                // 找到第一个交点
                for (let i = 0; i < parsedSectionPoints.length; i++) {
                    const p = parsedSectionPoints[i];
                    if (i === 0) {
                        if (p.y <= currentWaterLevel) {
                            startPoint = p;
                            inWater = true;
                            ctx.moveTo(toCanvasX(p.x), toCanvasY(p.y));
                        }
                    } else {
                        const prev = parsedSectionPoints[i - 1];
                        if (!inWater && prev.y > currentWaterLevel && p.y <= currentWaterLevel) {
                            // 计算交点
                            const x = prev.x + (p.x - prev.x) * (currentWaterLevel - prev.y) / (p.y - prev.y);
                            startPoint = { x, y: currentWaterLevel };
                            inWater = true;
                            ctx.moveTo(toCanvasX(x), toCanvasY(currentWaterLevel));
                        }
                    }

                    if (inWater) {
                        if (p.y <= currentWaterLevel) {
                            ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y));
                        } else {
                            // 计算交点
                            const prev = parsedSectionPoints[i - 1];
                            const x = prev.x + (p.x - prev.x) * (currentWaterLevel - prev.y) / (p.y - prev.y);
                            ctx.lineTo(toCanvasX(x), toCanvasY(currentWaterLevel));
                            inWater = false;
                        }
                    }
                }

                // 如果最后一个点在水位以下，连接到水位线
                const lastPoint = parsedSectionPoints[parsedSectionPoints.length - 1];
                if (lastPoint.y <= currentWaterLevel) {
                    ctx.lineTo(toCanvasX(lastPoint.x), toCanvasY(currentWaterLevel));
                }

                // 如果找到了起始点，闭合路径
                if (startPoint) {
                    ctx.lineTo(toCanvasX(startPoint.x), toCanvasY(currentWaterLevel));
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(6, 182, 212, 0.2)';
                    ctx.fill();
                }
            }

            // 如果有选中的数据，更新参数显示
            const parameterDisplay = document.getElementById('parameterDisplay');
            if (selectedData) {
                document.getElementById('paramArea').textContent = selectedData.a;
                document.getElementById('paramPerimeter').textContent = selectedData.p;
                document.getElementById('paramFlow').textContent = selectedData.q;
                parameterDisplay.classList.remove('hidden');
            } else {
                parameterDisplay.classList.add('hidden');
            }
        }

        function calculateGeometricProperties(segmentPoints, waterLevel) {
            let area = 0;
            let bedPerimeter = 0;
            if (!segmentPoints || segmentPoints.length < 2) {
                return { area: 0, bedPerimeter: 0 };
            }

            for (let i = 0; i < segmentPoints.length - 1; i++) {
                const p1 = segmentPoints[i];
                const p2 = segmentPoints[i + 1];

                const x1 = p1.x, y1 = p1.y;
                const x2 = p2.x, y2 = p2.y;
                const dx = x2 - x1;

                if (dx < 0) { console.warn("Segment points not sorted by X", p1, p2); continue; }
                if (dx === 0 && y1 === y2) continue; 

                const h1 = waterLevel - y1; 
                const h2 = waterLevel - y2; 

                if (y1 >= waterLevel && y2 >= waterLevel) { 
                    continue; 
                }

                if (y1 < waterLevel && y2 < waterLevel) { 
                    area += dx * (h1 + h2) / 2.0; 
                    bedPerimeter += Math.sqrt(dx * dx + (y2 - y1) * (y2 - y1));
                } else { 
                    if (y1 === y2) { 
                        if (y1 < waterLevel) { 
                             area += dx * h1; 
                        }
                        continue;
                    }
                    
                    const ix = x1 + dx * (waterLevel - y1) / (y2 - y1);

                    if (y1 < waterLevel) { 
                        area += (ix - x1) * h1 / 2.0; 
                        bedPerimeter += Math.sqrt(Math.pow(ix - x1, 2) + Math.pow(waterLevel - y1, 2));
                    } else { 
                        area += (x2 - ix) * h2 / 2.0; 
                        bedPerimeter += Math.sqrt(Math.pow(x2 - ix, 2) + Math.pow(waterLevel - y2, 2));
                    }
                }
            }
            return { area: Math.max(0, area), bedPerimeter: Math.max(0, bedPerimeter) };
        }

        function handleUpdatePreview() {
            if (parseSectionData()) {
                if (considerFloodplainEl.checked && (leftBankPointIndex === -1 || rightBankPointIndex === -1 || 
                    !parsedSectionPoints[leftBankPointIndex] || !parsedSectionPoints[rightBankPointIndex])) {
                     suggestInitialBankPoints(); 
                }
                 updateBankPointInfo(); 
                drawCrossSection();
            } else {
                 ctx.clearRect(0, 0, canvas.width, canvas.height); 
            }
        }

        function handleCalculate() {
            if (!parseSectionData()) return;

            const waterLevelStep = parseFloat(waterLevelIntervalEl.value);
            const n_val = parseFloat(manningNEl.value);
            const i_val = parseFloat(channelSlopeEl.value);
            const useManualLevels = useManualWaterLevelsEl.checked;

            if (isNaN(waterLevelStep) || waterLevelStep <= 0) {
                setStatusMessage('无效的水位间隔。', true); return;
            }
            if (isNaN(n_val) || n_val <= 0) {
                setStatusMessage('无效的曼宁糙率系数 (必须 > 0)。', true); return;
            }
            if (isNaN(i_val) || i_val <= 0) { 
                setStatusMessage('无效的河道坡降 (必须 > 0)。', true); return;
            }
            
            let minY_data = Infinity;
            let maxY_data_overall = -Infinity;
            if (parsedSectionPoints.length > 0) {
                parsedSectionPoints.forEach(p => {
                    minY_data = Math.min(minY_data, p.y);
                    maxY_data_overall = Math.max(maxY_data_overall, p.y);
                });
            } else { // No section data
                setStatusMessage('断面数据为空，无法计算。', true);
                resultsTableBody.innerHTML = '';
                noResultsMessageEl.classList.remove('hidden');
                drawCrossSection(); // Clear canvas or show empty state
                return;
            }


            let startWL, endWL; 

            if (useManualLevels) {
                const manualStart = parseFloat(manualStartWLEl.value);
                const manualEnd = parseFloat(manualEndWLEl.value);

                if (isNaN(manualStart) || isNaN(manualEnd)) {
                    setStatusMessage('手动输入的起始或终止水位无效。请检查输入。', true); return;
                }
                if (manualStart >= manualEnd) {
                    setStatusMessage('手动起始水位必须小于终止水位。', true); return;
                }
                // Optional: Warn if manualStart is below minY_data, but allow it.
                // if (manualStart < minY_data) {
                //    setStatusMessage(`警告: 手动起始水位 ${manualStart.toFixed(2)}m 低于河道最低点 ${minY_data.toFixed(2)}m。部分初始水位可能无水流。`, false); // false for warning
                // }
                startWL = manualStart;
                endWL = manualEnd;
                setStatusMessage('使用手动设定的水位范围进行计算。', false); // Set temporary success message
            } else {
                // --- Automatic startWL and endWL determination logic ---
                startWL = Math.ceil(minY_data / waterLevelStep) * waterLevelStep;
                if (startWL <= minY_data) startWL += waterLevelStep; 

                let endWL_max_coord = Math.max(parsedSectionPoints[0].y, parsedSectionPoints[parsedSectionPoints.length-1].y);
                endWL = Math.min(maxY_data_overall + waterLevelStep, endWL_max_coord + 10 * waterLevelStep); 

                if (considerFloodplainEl.checked && leftBankPointIndex !== -1 && rightBankPointIndex !== -1 &&
                    parsedSectionPoints[leftBankPointIndex] && parsedSectionPoints[rightBankPointIndex]) {
                    const YL_for_endWL = parsedSectionPoints[leftBankPointIndex].y;
                    const YR_for_endWL = parsedSectionPoints[rightBankPointIndex].y;
                    endWL = Math.max(endWL, YL_for_endWL + 5 * waterLevelStep, YR_for_endWL + 5 * waterLevelStep);
                    endWL = Math.min(endWL, maxY_data_overall + 5 * waterLevelStep); 
                }
                // Ensure endWL is sensible even for very flat or single point minY_data scenarios
                if (endWL < startWL && startWL > minY_data) { 
                    endWL = startWL + waterLevelStep * 5; 
                } else if (endWL < startWL) { // if startWL is already high due to minY_data being high
                    endWL = startWL + waterLevelStep * 5;
                }
            }


            if (startWL >= endWL + waterLevelStep/2) { 
                setStatusMessage('无法确定有效的计算水位范围 (起始水位 >= 终止水位)。请检查断面数据、岸顶定义、水位间隔或手动输入。', true);
                resultsTableBody.innerHTML = '';
                noResultsMessageEl.classList.remove('hidden');
                return;
            }

            resultsTableBody.innerHTML = ''; 
            let resultsData = [];
            let lastPlottedWL = null;

            for (let currentWL_iter = startWL; currentWL_iter <= endWL; currentWL_iter += waterLevelStep) {
                const currentWL = parseFloat(currentWL_iter.toFixed(5)); 

                let A_final = 0, P_final = 0, R_final = 0, Q_final = 0;
                let remark = "-";

                const floodplainActiveAndDefined = considerFloodplainEl.checked && 
                                                 leftBankPointIndex !== -1 && 
                                                 rightBankPointIndex !== -1 &&
                                                 parsedSectionPoints[leftBankPointIndex] && 
                                                 parsedSectionPoints[rightBankPointIndex];

                if (!floodplainActiveAndDefined) {
                    const geom = calculateGeometricProperties(parsedSectionPoints, currentWL);
                    A_final = geom.area;
                    P_final = geom.bedPerimeter; 
                    
                    if (A_final > 0 && P_final > 0) {
                        R_final = A_final / P_final;
                        if (n_val > 0 && i_val > 0) {
                           Q_final = (1 / n_val) * A_final * Math.pow(R_final, 2/3) * Math.pow(i_val, 1/2);
                        } else { Q_final = 0; }
                    } else { R_final = 0; Q_final = 0; }
                } else {
                    const YL_val = parsedSectionPoints[leftBankPointIndex].y;
                    const YR_val = parsedSectionPoints[rightBankPointIndex].y;
                    // hBankfull is already globally updated

                    if (currentWL > hBankfull) { 
                        remark = "漫滩";
                    } else {
                        remark = "主槽"; 
                    }

                    const points_mc = parsedSectionPoints.slice(leftBankPointIndex, rightBankPointIndex + 1);
                    const points_lfp = parsedSectionPoints.slice(0, leftBankPointIndex + 1);
                    const points_rfp = parsedSectionPoints.slice(rightBankPointIndex);

                    const geom_mc = calculateGeometricProperties(points_mc, currentWL);
                    let A_mc = geom_mc.area;
                    let P_mc_bed = geom_mc.bedPerimeter;
                    let P_mc = P_mc_bed + Math.max(0, currentWL - YL_val) + Math.max(0, currentWL - YR_val);
                    let R_mc = (A_mc > 0 && P_mc > 0) ? A_mc / P_mc : 0;
                    let Q_mc = (A_mc > 0 && R_mc > 0 && n_val > 0 && i_val > 0) ? 
                               (1/n_val) * A_mc * Math.pow(R_mc, 2/3) * Math.pow(i_val, 1/2) : 0;
                    if (A_mc <= 0) Q_mc = 0;

                    let A_lfp = 0, Q_lfp = 0;
                    if (currentWL > YL_val) { 
                        const geom_lfp = calculateGeometricProperties(points_lfp, currentWL);
                        A_lfp = geom_lfp.area;
                        if (A_lfp > 0) {
                            let P_lfp_bed_component = geom_lfp.bedPerimeter;
                            let P_lfp_component = P_lfp_bed_component + Math.max(0, currentWL - YL_val);
                            let R_lfp_component = (P_lfp_component > 0) ? A_lfp / P_lfp_component : 0;
                            Q_lfp = (A_lfp > 0 && R_lfp_component > 0 && n_val > 0 && i_val > 0) ? 
                                    (1/n_val) * A_lfp * Math.pow(R_lfp_component, 2/3) * Math.pow(i_val, 1/2) : 0;
                        }
                    }
                    if (A_lfp <= 0) Q_lfp = 0; 

                    let A_rfp = 0, Q_rfp = 0;
                    if (currentWL > YR_val) { 
                        const geom_rfp = calculateGeometricProperties(points_rfp, currentWL);
                        A_rfp = geom_rfp.area;
                        if (A_rfp > 0) {
                            let P_rfp_bed_component = geom_rfp.bedPerimeter;
                            let P_rfp_component = P_rfp_bed_component + Math.max(0, currentWL - YR_val);
                            let R_rfp_component = (P_rfp_component > 0) ? A_rfp / P_rfp_component : 0;
                            Q_rfp = (A_rfp > 0 && R_rfp_component > 0 && n_val > 0 && i_val > 0) ? 
                                    (1/n_val) * A_rfp * Math.pow(R_rfp_component, 2/3) * Math.pow(i_val, 1/2) : 0;
                        }
                    }
                    if (A_rfp <= 0) Q_rfp = 0; 

                    Q_final = Q_mc + Q_lfp + Q_rfp;
                    A_final = A_mc + A_lfp + A_rfp;
                    
                    if (A_final > 0 && Q_final > 0 && n_val > 0 && i_val > 0) {
                        R_final = Math.pow((Q_final * n_val) / (A_final * Math.pow(i_val, 0.5)), 1.5);
                        P_final = (R_final > 0 && isFinite(R_final)) ? A_final / R_final : Infinity; // Check R_final is finite
                    } else if (A_final > 0) {
                        R_final = 0;
                        P_final = Infinity; 
                    } else { 
                        R_final = 0;
                        P_final = 0;
                    }
                }
                
                if (A_final > 0 || (A_final === 0 && currentWL >= minY_data) ) {
                     if (A_final === 0 && Q_final === 0 && P_final === 0 && R_final === 0 && currentWL < minY_data + waterLevelStep * 0.01 ) {
                        // Skip if truly no water and WL is very close to or below lowest point
                     } else {
                        resultsData.push({
                            wl: currentWL.toFixed(3),
                            a: A_final.toFixed(2),
                            p: P_final === Infinity ? "Inf." : (isFinite(P_final) ? P_final.toFixed(2) : "Inf."),
                            r: R_final.toFixed(2),
                            q: Q_final.toFixed(2),
                            rem: remark
                        });
                        if (A_final > 0) lastPlottedWL = currentWL;
                     }
                }
            }

            if (resultsData.length > 0) {
                resultsData.forEach(data => {
                    const row = resultsTableBody.insertRow();
                    row.addEventListener('click', handleTableRowClick); // 添加点击事件监听器
                    
                    row.insertCell().textContent = data.wl;
                    row.insertCell().textContent = data.a;
                    row.insertCell().textContent = data.p;
                    row.insertCell().textContent = data.r;
                    row.insertCell().textContent = data.q;
                    const remarkCell = row.insertCell();
                    remarkCell.textContent = data.rem;
                    if (data.rem === "漫滩") {
                        remarkCell.classList.add('remark-flood');
                    } else if (data.rem === "主槽") {
                        remarkCell.classList.add('remark-main');
                    }
                });
                
                // 默认选中第一行
                const firstRow = resultsTableBody.firstElementChild;
                if (firstRow) {
                    firstRow.click();
                }
                
                noResultsMessageEl.classList.add('hidden');
                if (!useManualLevels || statusMessageEl.classList.contains('error') || resultsData.length > 0) {
                    setStatusMessage(`计算完成，共 ${resultsData.length} 条结果。`, false);
                }

                const wlToDraw = lastPlottedWL !== null ? lastPlottedWL : 
                                (resultsData.length > 0 ? parseFloat(resultsData[resultsData.length-1].wl) : 
                                (parsedSectionPoints.length > 0 ? minY_data : null) );
                drawCrossSection(wlToDraw);
            } else {
                noResultsMessageEl.classList.remove('hidden');
                setStatusMessage('在设定的计算范围内未能得到有效的水力计算结果。请检查输入或调整水位范围。', true);
                drawCrossSection(); 
            }
        }

        function clearAll() {
            sectionDataEl.value = '';
            waterLevelIntervalEl.value = '0.5';
            manningNEl.value = '0.03';
            channelSlopeEl.value = '0.00177'; // Reset to original default
            
            // Clear manual water level controls
            useManualWaterLevelsEl.checked = false;
            manualWaterLevelControlsEl.classList.add('hidden');
            manualStartWLEl.value = '';
            manualEndWLEl.value = '';

            considerFloodplainEl.checked = false;
            floodplainControlsEl.classList.add('hidden');
            
            parsedSectionPoints = [];
            leftBankPointIndex = -1;
            rightBankPointIndex = -1;
            hBankfull = -1;
            updateBankPointInfo();
            
            resultsTableBody.innerHTML = '';
            noResultsMessageEl.classList.add('hidden'); // Ensure this is hidden on clear
            setStatusMessage('所有输入已清空。', false);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCrossSection(null, null); // 清除参数框
            document.getElementById('parameterDisplay').classList.add('hidden');
        }

        function copyResultsToClipboard() {
            const rows = Array.from(resultsTableBody.rows);
            if (rows.length === 0) {
                setStatusMessage('没有结果可以复制。', true);
                return;
            }
            const header = Array.from(document.getElementById('resultsTable').getElementsByTagName('th'))
                                .map(th => th.textContent).join('\t');
            const data = rows.map(row => 
                Array.from(row.cells).map(cell => cell.textContent).join('\t')
            ).join('\n');
            
            const fullText = header + '\n' + data;

            navigator.clipboard.writeText(fullText).then(() => {
                setStatusMessage('结果已复制到剪贴板。', false);
            }).catch(err => {
                setStatusMessage('复制失败: ' + err, true);
                // Fallback for browsers that might restrict clipboard API in iframes or secure contexts
                try {
                    const textArea = document.createElement("textarea");
                    textArea.value = fullText;
                    textArea.style.position = "fixed"; // Prevent scrolling to bottom of page
                    textArea.style.top = "0";
                    textArea.style.left = "0";
                    textArea.style.opacity = "0"; // Make it invisible
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    setStatusMessage('结果已复制到剪贴板 (fallback)。', false);
                } catch (e) {
                    setStatusMessage('复制失败，请手动选择复制。 ' + e, true);
                }
            });
        }
        
        function setStatusMessage(message, isError = false) {
            statusMessageEl.textContent = message;
            statusMessageEl.className = 'mt-2 p-3 rounded-md text-sm'; // Reset classes
            if (isError) {
                statusMessageEl.classList.add('error');
            } else {
                statusMessageEl.classList.add('success');
            }
        }

        // 添加表格行点击事件处理
        function handleTableRowClick(event) {
            const row = event.currentTarget;
            const cells = row.cells;
            
            // 移除其他行的选中状态
            const allRows = resultsTableBody.getElementsByTagName('tr');
            Array.from(allRows).forEach(r => r.classList.remove('selected'));
            
            // 添加当前行的选中状态
            row.classList.add('selected');
            
            // 获取该行的数据
            const selectedData = {
                wl: cells[0].textContent,
                a: cells[1].textContent,
                p: cells[2].textContent,
                r: cells[3].textContent,
                q: cells[4].textContent,
                rem: cells[5].textContent
            };
            
            // 重绘断面图，传入选中的水位和数据
            drawCrossSection(parseFloat(selectedData.wl), selectedData);
        }

        function updateQHPlot() {
            const dpr = window.devicePixelRatio || 1;
            const rect = qhCanvas.getBoundingClientRect();
            qhCanvas.width = rect.width * dpr;
            qhCanvas.height = rect.height * dpr;
            qhCtx.scale(dpr, dpr);

            // 获取计算结果数据
            const rows = Array.from(resultsTableBody.rows);
            if (rows.length === 0) {
                setStatusMessage('没有数据可以绘制。', true);
                return;
            }

            // 提取水位和流量数据
            const data = rows.map(row => ({
                h: parseFloat(row.cells[0].textContent),
                q: parseFloat(row.cells[4].textContent)
            })).filter(d => !isNaN(d.h) && !isNaN(d.q));

            // 计算数据范围
            const qMin = Math.min(...data.map(d => d.q));
            const qMax = Math.max(...data.map(d => d.q));
            const hMin = Math.min(...data.map(d => d.h));
            const hMax = Math.max(...data.map(d => d.h));

            // 使用配置或自动计算的轴范围
            const xMin = qhPlotConfig.xAxis.min ?? qMin;
            const xMax = qhPlotConfig.xAxis.max ?? qMax;
            const yMin = qhPlotConfig.yAxis.min ?? hMin;
            const yMax = qhPlotConfig.yAxis.max ?? hMax;

            // 设置绘图区域
            const padding = 60;
            const width = qhCanvas.width / dpr - 2 * padding;
            const height = qhCanvas.height / dpr - 2 * padding;

            // 坐标转换函数
            const toCanvasX = q => padding + (q - xMin) * width / (xMax - xMin);
            const toCanvasY = h => qhCanvas.height / dpr - padding - (h - yMin) * height / (yMax - yMin);

            // 清空画布
            qhCtx.clearRect(0, 0, qhCanvas.width / dpr, qhCanvas.height / dpr);

            // 绘制网格
            if (qhPlotConfig.showGrid) {
                const xStep = qhPlotConfig.xAxis.step ?? calculateNiceNumber((xMax - xMin) / 10, true);
                const yStep = qhPlotConfig.yAxis.step ?? calculateNiceNumber((yMax - yMin) / 10, true);

                qhCtx.beginPath();
                qhCtx.strokeStyle = '#f3f4f6';
                qhCtx.lineWidth = 1;

                // 垂直网格线
                for (let q = Math.ceil(xMin / xStep) * xStep; q <= xMax; q += xStep) {
                    const x = toCanvasX(q);
                    qhCtx.moveTo(x, padding);
                    qhCtx.lineTo(x, qhCanvas.height / dpr - padding);
                }

                // 水平网格线
                for (let h = Math.ceil(yMin / yStep) * yStep; h <= yMax; h += yStep) {
                    const y = toCanvasY(h);
                    qhCtx.moveTo(padding, y);
                    qhCtx.lineTo(qhCanvas.width / dpr - padding, y);
                }
                qhCtx.stroke();
            }

            // 绘制坐标轴
            qhCtx.beginPath();
            qhCtx.strokeStyle = '#9ca3af';
            qhCtx.lineWidth = 1.5;
            // X轴
            qhCtx.moveTo(padding, qhCanvas.height / dpr - padding);
            qhCtx.lineTo(qhCanvas.width / dpr - padding, qhCanvas.height / dpr - padding);
            // Y轴
            qhCtx.moveTo(padding, padding);
            qhCtx.lineTo(padding, qhCanvas.height / dpr - padding);
            qhCtx.stroke();

            // 绘制刻度和标签
            qhCtx.fillStyle = '#4b5563';
            qhCtx.font = '12px Inter';

            // X轴（流量）刻度和标签
            const xStep = qhPlotConfig.xAxis.step ?? calculateNiceNumber((xMax - xMin) / 10, true);
            for (let q = Math.ceil(xMin / xStep) * xStep; q <= xMax; q += xStep) {
                const x = toCanvasX(q);
                qhCtx.beginPath();
                qhCtx.moveTo(x, qhCanvas.height / dpr - padding);
                qhCtx.lineTo(x, qhCanvas.height / dpr - padding + 5);
                qhCtx.stroke();
                qhCtx.textAlign = 'center';
                qhCtx.fillText(q.toFixed(2), x, qhCanvas.height / dpr - padding + 20);
            }

            // Y轴（水位）刻度和标签
            const yStep = qhPlotConfig.yAxis.step ?? calculateNiceNumber((yMax - yMin) / 10, true);
            for (let h = Math.ceil(yMin / yStep) * yStep; h <= yMax; h += yStep) {
                const y = toCanvasY(h);
                qhCtx.beginPath();
                qhCtx.moveTo(padding - 5, y);
                qhCtx.lineTo(padding, y);
                qhCtx.stroke();
                qhCtx.textAlign = 'right';
                qhCtx.fillText(h.toFixed(2), padding - 8, y + 4);
            }

            // 添加轴标题
            qhCtx.save();
            qhCtx.translate(padding - 40, qhCanvas.height / dpr / 2);
            qhCtx.rotate(-Math.PI / 2);
            qhCtx.textAlign = 'center';
            qhCtx.fillText('水位 (m)', 0, 0);
            qhCtx.restore();

            qhCtx.textAlign = 'center';
            qhCtx.fillText('流量 (m³/s)', qhCanvas.width / dpr / 2, qhCanvas.height / dpr - padding + 35);

            // 绘制数据点和线
            if (qhPlotConfig.smoothLine) {
                // 绘制平滑曲线
                qhCtx.beginPath();
                qhCtx.strokeStyle = '#3b82f6';
                qhCtx.lineWidth = 2;
                
                // 使用三次样条插值
                const points = data.map(d => ({
                    x: toCanvasX(d.q),
                    y: toCanvasY(d.h)
                }));
                
                qhCtx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length - 2; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    qhCtx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                }
                qhCtx.quadraticCurveTo(
                    points[points.length - 2].x,
                    points[points.length - 2].y,
                    points[points.length - 1].x,
                    points[points.length - 1].y
                );
                qhCtx.stroke();
            } else {
                // 绘制折线
                qhCtx.beginPath();
                qhCtx.strokeStyle = '#3b82f6';
                qhCtx.lineWidth = 2;
                data.forEach((d, i) => {
                    const x = toCanvasX(d.q);
                    const y = toCanvasY(d.h);
                    if (i === 0) qhCtx.moveTo(x, y);
                    else qhCtx.lineTo(x, y);
                });
                qhCtx.stroke();
            }

            // 绘制数据点
            if (qhPlotConfig.showPoints) {
                data.forEach(d => {
                    const x = toCanvasX(d.q);
                    const y = toCanvasY(d.h);
                    
                    // 绘制点的外圈（白色边框）
                    qhCtx.beginPath();
                    qhCtx.arc(x, y, 4, 0, 2 * Math.PI);
                    qhCtx.fillStyle = '#ffffff';
                    qhCtx.fill();
                    qhCtx.strokeStyle = '#3b82f6';
                    qhCtx.lineWidth = 2;
                    qhCtx.stroke();
                    
                    // 绘制点的内圈
                    qhCtx.beginPath();
                    qhCtx.arc(x, y, 2, 0, 2 * Math.PI);
                    qhCtx.fillStyle = '#3b82f6';
                    qhCtx.fill();

                    // 绘制数据标签
                    if (qhPlotConfig.showDataLabels) {
                        qhCtx.fillStyle = '#4b5563';
                        qhCtx.textAlign = 'left';
                        qhCtx.textBaseline = 'bottom';
                        qhCtx.fillText(`(${d.q.toFixed(2)}, ${d.h.toFixed(2)})`, x + 8, y - 8);
                    }
                });
            }
        }

        // Initial setup
        handleUpdatePreview(); 
        // Set initial status message if needed, or leave it to be set by actions
        // setStatusMessage("请输入断面数据和参数后点击"预览/更新断面"或"计算"。", false) 

    </script>
</body>
</html>


